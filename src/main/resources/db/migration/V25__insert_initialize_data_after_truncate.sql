# --- collection data ---
INSERT INTO `collection` (`id`, `title`, `title_translation`, `slug`, `type`, `content`, `video`, `duration`, `cover`, `description`, `published`, `free`, `price`, `view_count`, `seo_title`, `seo_description`, `completed`, `proofread`, `user_id`, `created_at`, `updated_at`, `deleted_at`)
VALUES
	(1,'Docker 快速入门文档',NULL,'docker-get-started__doc','doc',NULL,NULL,0,'https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/cover/1/xQkug4WdwX1628302147.png','Docker 官方入门文档不完全翻译。介绍了什么是容器、什么是镜像、以及如何创建镜像、运行容器、构建镜像最佳实践等 Docker 基础知识。',1,1,0.00,0,NULL,NULL,1,0,1,now(),NULL,NULL),
	(2,'Getting Started with Java',NULL,'getting-started-with-java','doc',NULL,NULL,0,'https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/cover/collection/ab04aca4-68df-4da7-90eb-d0adf90bcf4b.png','This trail provides everything you\'ll need to know about getting started with the Java programming language.',1,1,0.00,0,NULL,NULL,1,0,1,now(),NULL,NULL);



# --- section data ---
INSERT INTO `section` (`id`, `slug`, `title`, `title_translation`, `description`, `sort_order`, `collection_id`, `created_at`, `updated_at`, `deleted_at`)
VALUES
	(1,NULL,'Docker 初体验',NULL,'',0,1,now(),NULL,NULL),
	(2,NULL,'创建、更新、分享 Docker 镜像',NULL,'',0,1,now(),NULL,NULL),
	(3,NULL,'进一步了解 Docker',NULL,'',0,1,now(),NULL,NULL),
	(4,NULL,'小结',NULL,'',0,1,now(),NULL,NULL),
	(5,NULL,'The Java Technology Phenomenon',NULL,'Provides an overview of Java technology as a whole. It discusses both the Java programming language and platform, providing a broad overview of what this technology can do and how it will make your life easier.',0,2,now(),NULL,NULL),
	(6,NULL,'The \"Hello World!\" Application',NULL,'This hands-on approach describes what to download, what to install, and what to type, for creating a simple \"Hello World!\" application. It provides separate instructions for the NetBeans™ integrated development environment (NetBeans IDE), Microsoft Windows, Solaris™ Operating System (Solaris OS), Linux, and Mac users.',0,2,now(),NULL,NULL),
	(7,NULL,'A Closer Look at \"Hello World!\"',NULL,'Discusses the \"Hello World!\" application, describing each section of code in detail. It covers source code comments, the HelloWorldApp class definition block, and the main method.',0,2,now(),NULL,NULL),
	(8,NULL,'Common Problems',NULL,'This is the place to go if you have trouble compiling or running the programs in this trail.',0,2,now(),NULL,NULL);



# --- lecture data ---
INSERT INTO `lecture` (`id`, `title`, `title_translation`, `slug`, `content`, `video`, `video_id`, `duration`, `description`, `description_translation`, `sort_order`, `published`, `free`, `requires_login`, `cover`, `section_id`, `collection_id`, `created_at`, `updated_at`, `deleted_at`)
VALUES
	(1,'安装 Docker',NULL,'docker-install__doc','开始学习之前，需要先安装并启动 Docker\r\n\r\n## 安装 Docker\r\n\r\n- [在 Windows 上安装 Docker](https://docs.docker.com/docker-for-windows/install/)\r\n- [在 Mac 上安装 Docker](https://docs.docker.com/docker-for-mac/install/)\r\n- [在 Ubuntu 上安装 Docker](https://docs.docker.com/engine/install/ubuntu/)\r\n- [在 CentOS 上安装 Docker](https://docs.docker.com/engine/install/centos/)\r\n- 更多支持的系统，查看[官方文档](https://docs.docker.com/engine/install/)\r\n\r\n## 启动 Docker\r\n\r\n本文以 MacOS 为例：\r\n\r\n1. 双击已经安装好的 Docker 应用图标\r\n   ![docker desktop](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/mlmLZ1628304059_docker_desktop1617268347.png)\r\n2. Docker 应用启动成功之后，可以在顶部状态栏的右上角位置看到它的图标\r\n   ![docker desktop status bar](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/r6Lsc1628304059_docker_desktop_status_bar1617268347.png)\r\n3. 点击顶部状态栏上的 Docker 图标，可以进一步查看和操作 Docker\r\n   ![docker desktop more actions](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/b6wey1628304059_docker_desktop_more_actions1617268347.png)\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,1,1,now(),NULL,NULL),
	(2,'运行第一个 Docker 容器',NULL,'docker-getting-started__doc','## 执行 `docker run` 命令\r\n\r\n打开命令行工具，执行以下命令\r\n\r\n```shell\r\ndocker run -d -p 8000:80 docker/getting-started\r\n```\r\n\r\n等这条命令执行成功之后，docker 已经为我们启动了一个新的容器，在容器的 80 端口上运行着一个 `getting-started`  Web 服务，并将本机上的 8000 端口映射到容器中的 80 端口。\r\n\r\n因此，现在可以直接在本机访问 [http://localhost:8000](http://localhost:8080) 即可访问到容器中 80 端口上启动的 `getting-started`  Web 服务了。\r\n\r\n至此，我们已经启动了第一个 Docker 容器。先学会如何使用、先观察到效果，是循序渐进学习的重点；至于什么是容器，什么是镜像将在后续慢慢展开介绍。\r\n\r\n> 部分参数说明：\r\n> \r\n> - `docker/getting-started` - 使用的镜像名称\r\n> - `-p 8000:80` - 将本机上的 8000 端口映射到容器中的 80 端口\r\n> - `-d` - 让容器保持在后台运行，返回容器 ID\r\n>   \r\n>   备注：类似 -d 和 -p 这种单个字符的参数可以进行合并，所以上一条命令可以简写为：\r\n>   `docker run -dp 8000:80 docker/getting-started`\r\n\r\n## Docker Dashboard\r\n\r\n刚才提到的容器和镜像，在哪里可以看到它们？\r\n\r\n方法 1：通过执行 Docker 提供的 cli 命令查看\r\n\r\n- `docker container ls` - 查看正在运行的容器\r\n- `docker images` - 查看有哪些镜像\r\n\r\n方法 2：通过 Docker 提供的可视化界面 Docker Dashboard 查看\r\n\r\n![Docker Dashboard menu](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/teMmo1628305176_Docker_Dashboard_menu1617268364.png)\r\n\r\nDocker Dashboard 不止可以快速查看机器上运行的容器和拥有的镜像。还可以快速访问容器日志、轻松管理容器的生命周期（启动、停止，删除等...）更多功能可以参考官方文档 [Mac 版本](https://docs.docker.com/docker-for-mac/dashboard/) 或 [Windows 版本](https://docs.docker.com/docker-for-windows/dashboard/)。\r\n如果现在你已经打开了 Docker Dashboard，将会看到本教程的 getting-started 容器正在运行中。容器名称默认是随机创建的（如下图显示的 `agitated_chaplygin`）你自己看到到很可跟下图显示的不一致：\r\n\r\n![Tutorial container running in Docker Dashboard](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/Jy90L1628305176_Tutorial_container_running_in_Docker_Dashboard1617268365.png)\r\n\r\n当然，也可以自己指定容器的名称，只需在运行容器时增加 `--name` 参数，主动指定容器名称即可，如：\r\n`docker run -d -p 8000:80 --name container-name docker/getting-started`\r\n\r\n## 什么是容器?\r\n\r\n简而言之，容器只是在你计算机上的另一个进程，但是这个进程与主机上的所有其他进程是相互隔离的。这种隔离利用了 Linux 上已经存在很长时间的功能：[内核名称空间和 cgroup](https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504)。Docker 致力于使这些功能更容易实现、更便于使用。\r\n\r\n## 什么是镜像?\r\n\r\n容器运行时使用的是隔离的文件系统。这个自定义的文件系统就是由 `镜像` 提供。由于镜像包含容器的文件系统，因此它必须包含运行应用程序所需的所有内容：所有依赖项、配置、脚本、二进制文件等。该镜像还包含容器的其他配置，例如环境变量、要运行的默认命令以及其他元数据。后续将会更深入的研究镜像，诸如镜像的分层，构建镜像的最佳实践等主题。\r\n\r\n> 原始资料：[Get Started](https://docs.docker.com/get-started/)\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,1,1,now(),NULL,NULL),
	(3,'创建自己的 Docker 镜像',NULL,'our-docker-image__doc','本教程将通过一个最简单的、使用 JavaScript 开发的待办事项管理 Web 应用程序贯穿始终，下文简称为：`todo-app`。这个应用程序的代码已经写好并提供了源码的下载地址，所以如果你不太熟悉 JavaScript 和 Node.js 也完全没有任何关系，依旧可以很轻松的学习本教程，因为我们的学习重点是 Docker，所以放心的继续往下看吧。\r\n\r\n此时，你只是想开发一个最小可行产品（MVP）来证明自己的想法，展示它的工作原理和功能,暂时无需考虑其他复杂因素。\r\n\r\n![Todo List Manager Screenshot](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/6HKyC1628305251_Todo_List_Manager_Screenshot1617268644.png)\r\n\r\n## 获取 `todo-app` 源码\r\n\r\n在运行 `todo-app` 之前，需要将它的源代码下载到自己的计算机上。在实际工作中开发的项目，通常是去公司的代码仓库克隆。但是，针对本教程，我们创建好了一个包含应用程序源码的 ZIP 压缩文件。\r\n\r\n1. [点击这里下载](https://default-sz.oss-cn-shenzhen.aliyuncs.com/docker/app.zip) 并解压，解压之后默认文件夹名称是 `app`， 非必要的情况下，不要修改文件夹名称，因为保存名称一致，有利于后续文档的说明。\r\n2. 使用你喜欢的编辑器打开，下图使用的是 [Visual Studio Code](https://code.visualstudio.com/) 编辑器作为演示，你可以使用任何自己喜欢的编辑器打开它，打开之后会看到 `package.json` 文件、 `yarn.lock` 文件和两个子目录 `src` 和 `spec`。\r\n   ![Screenshot of Visual Studio Code opened with the app loaded](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/HkQ7M1628305251_Screenshot_of_Visual_Studio_Code_opened_with_the_app_loaded1617268644.png)\r\n\r\n## 为 `todo-app` 创建镜像\r\n\r\n需要一个 `Dockerfile` 文件来为我们的应用程序创建 Docker 容器镜像。`Dockerfile` 文件就是一个文本文件，文本的内容描述着如何一步步构建出我们需要的镜像。\r\n\r\n1. 创建一个名为 `Dockerfile` 的文件，与 `package.json` 文件同一层级，内容如下：\r\n   \r\n   ```\r\n   FROM node:12-alpine\r\n   WORKDIR /app\r\n   COPY . .\r\n   RUN yarn install --production\r\n   CMD [\"node\", \"src/index.js\"]\r\n   ```\r\n   \r\n   这个 `Dockerfile` 的每一行都代表着告诉 Docker 镜像构造器每一步该怎么做：\r\n   \r\n   - 我们的镜像要基于 `node: 12-alpine` 镜像\r\n   - 指定镜像的工作目录是 `/app`\r\n   - 接着将主机上当前项目目录下的所有内容（即：`app` 目录下的所有内容）复制到镜像中的当前工作目录（即：`/app` 目录下）\r\n   - 接着执行 `yarn install --production` 命令为 `todo-app` 安装依赖\r\n   - 最后一步通过 `CMD` 指定镜像被启动时默认要执行的命令，即通过 node 真正启动我们的 `todo-app` Web 应用程序。\r\n   \r\n   > 备注：确保刚刚创建的 `Dockerfile` 文件没有文件扩展名，有些编辑器可能会自动附加文件扩展名。\r\n2. 打开命令行并进入到 `Dockerfile` 文件所在的 `app` 目录，执行如下命令：\r\n   \r\n   ```\r\n   docker build -t todo-app .\r\n   ```\r\n   \r\n   这条命令就是使用刚刚创建的 `Dockerfile` 文件构建出一个新的容器镜像。从这条命令的输出结果中，你应该已经注意到有很多步骤，对应着 `Dockerfile` 文件的每一行。\r\n   `-t` 标志代表为我们的镜像打标签，可以简单地理解成为镜像取一个易于理解的名称。由于我们将镜像命名为 `todo-app` 因此可以在运行容器时引用这个镜像名称。docker build 命令最后的 `.` 代表告诉 Docker 在当前目录下查找 `Dockerfile` 文件。\r\n\r\n## 用刚创建的镜像启动容器\r\n\r\n现在已经为我们的 `todo-app` 应用创建了一个名字为 `todo-app` 的 Docker 镜像，看看如何使用它：\r\n\r\n1. 使用 `docker run` 命令启动一个新容器，并指定使用我们刚刚创建的镜像：\r\n   \r\n   ```\r\n   docker run -dp 3000:3000 todo-app\r\n   ```\r\n   \r\n   还记得 `-d` 和 `-p` 标记吗?\r\n   `-d` - 让容器保持在后台运行；\r\n   `-p 3000:3000` - 将容器中的 3000 端口映射到本机的 3000 端口。\r\n   因此，通过这条命令，我们使用自己创建的 `todo-app` 镜像启动了一个新容器。在容器中的 3000 端口上启动着我们自己的 `todo-app` Web 应用程序，并将容器中的 3000 端口映射到本机的 3000 端口。\r\n2. 在本机上访问 [http://localhost:3000](http://localhost:3000/) 就可以看到我们自己的应用了：\r\n   ![Empty Todo List](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/ZC3xz1628305251_Empty_Todo_List1617268645.png)\r\n\r\n此时，一个由我们自己亲手创建的 `todo-app` 应用已经运行在 Docker 上了。\r\n\r\n## 回顾\r\n\r\n在这一小节中，我们学习了有关构建容器镜像的基础知识，并创建了一个 `Dockerfile` 来完成此操作。构建镜像完成之后，我们使用该镜像启动了一个新容器并看到了正在运行的、我们自己的 `todo-app` 应用。\r\n\r\n接下来，将对我们的应用程序进行修改。在此过程中，进一步学习 Docker 的其他知识。\r\n\r\n> 原始资料：[Our Application](https://docs.docker.com/get-started/02_our_app/)\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,2,1,now(),NULL,NULL),
	(4,'更新应用并重新构建 Docker 镜像',NULL,'updating-our-dockder-image__doc','现在要对我们的应用做一点点小更新：\r\n\r\n## 修改源码\r\n\r\n1. 修改 `src/static/js/app.js` 文件的第 56 行：将 `No items yet! Add one above!` 修改为 `You have no todo items yet! Add one above!`\r\n2. 输入之前使用过的命令，重新构建镜像\r\n   \r\n   ```\r\n   docker build -t todo-app .\r\n   ```\r\n3. 使用新版本镜像运行容器\r\n   \r\n   ```\r\n   docker run -dp 3000:3000 todo-app\r\n   ```\r\n   \r\n   你可能会看到如下错误信息：\r\n\r\n```\r\ndocker: Error response from daemon: driver failed ...... Bind for 0.0.0.0:3000 failed: port is already allocated.\r\n```\r\n\r\n之所以出现这个问题，是因为本机的 3000 端口已经被我们之前启动的容器占用了。要解决此问题，我们可以删除旧的容器。\r\n\r\n## 删除容器\r\n\r\n要删除容器，首先需要将其停止，然后将其删除。有两种方法可以停止并删除容器：\r\n\r\n### 使用 CLI 命令删除容器\r\n\r\n1. 使用 `docker ps` 命令获取容器的 ID\r\n   ```\r\n   docker ps\r\n   ```\r\n2. 使用 `docker stop` 命令停止容器\r\n   ```\r\n   # 将下方的 <the-container-id> 替换成你想停止的容器 ID\r\n   docker stop <the-container-id>\r\n   ```\r\n3. 容器停止后，可以使用 `docker rm` 命令删除它\r\n   ```\r\n   # 将下方的 <the-container-id> 替换成你想删除的容器 ID\r\n   docker rm <the-container-id>\r\n   ```\r\n\r\n> 备注：\r\n> 可以通过增加 `-f` 标志来合并上面的第 2、3 步，使用一条命令停止并删除容器。如：`docker rm -f <the-container-id>`\r\n\r\n### 使用 Docker Dashboard 删除容器\r\n\r\n通过 Docker Dashboard 可以很方便的删除容器，比通过 CLI 命令查找容器 ID 之后再将其删除要容易得多。\r\n\r\n1. 打开 Docker Dashboard 之后，将鼠标悬停在应用程序容器上，在右侧会看到一系列可以对容器进行操作的按钮\r\n2. 点击垃圾桶图标删除容器\r\n3. 在弹出的确认窗口中真正删除它\r\n   ![Docker Dashboard - removing a container](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/JycIY1628305342_Docker_Dashboard_-_removing_a_container1617268738.png)\r\n\r\n> 备注：在 Docker Dashboard 中我们还看到了另一个非绿色图标显示的容器，这个容器是没有启动成功的，就是上一次执行命令出现报错的时候留下来的，我们也可以用同样的操作删除掉它。\r\n> ![Docker Dashboard - removing another container](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/jPMjx1628305342_Docker_Dashboard_-_removing_another_container1617268739.png)\r\n\r\n### 再一次使用新版本镜像运行容器\r\n\r\n1. 运行新容器\r\n   ```\r\n   docker run -dp 3000:3000 todo-app\r\n   ```\r\n2. 再一次访问 [http://localhost:3000](http://localhost:3000/) 将会看到我们更新之后的效果了\r\n\r\n![Updated application with updated empty text](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/0H45P1628305342_Updated_application_with_updated_empty_text1617268739.png)\r\n\r\n## 回顾\r\n\r\n在本节中，我们修改了源代码，同时重新执行了构建镜像命令。\r\n\r\n虽然我们成功构建了新版本镜像，但是你可能已经注意到了两个小问题：\r\n\r\n* 镜像更新之前添加的所有代办事项，全部都消失了，数据没有被保存起来\r\n* 本次修改只是一个非常简单的文字更新，但是重新构建镜像的过程中，`Dockerfile` 文件列出的每一个步骤都需要重新执行一遍。肯定还有更高效的方式让容器感知代码的变化，而不必重新执行所有步骤。\r\n\r\n之后的章节将会解决这两个问题，在开始解决这些问题之前，让我们先快速了解一下如何把我们构建好的镜像分享给其他人使用。\r\n\r\n> 原始资料：[Updating our Application](https://docs.docker.com/get-started/03_updating_app/)\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,2,1,now(),NULL,NULL),
	(5,'分享自己创建的 Docker 镜像',NULL,'sharing-our-docker-image__doc','现在我们已经构建了自己的镜像，是时候把它分享给其他人使用了！要分享 Docker 镜像，需要使用 Docker registry，默认的 registry 是 Docker Hub\r\n\r\n> 备注：本文档不对 `registry` 和 `repository` 进行翻译，出现它们的地方都保留原始英文。\r\n> Registry 和 Repository 的区别\r\n> \r\n> - [Registry 的官方解释](https://docs.docker.com/registry/)：The Registry is a stateless, highly scalable server side application that stores and lets you distribute Docker images. The Registry is open-source, under the permissive [Apache license](https://en.wikipedia.org/wiki/Apache_License).  Registry 是一个无状态、高可用的服务端程序，用于存储和分发 Docker 镜像。同时它是一个基于 Apache license 的开源程序。正是由于它是开源的，所有除了 Docker 官方的 registry （即：Docker Hub）还有很多第三代的 registry，甚至你还可以自己部署一个 registry。\r\n> - Repository 是 registry 内部真正保存具体每个镜像内容的地方。\r\n\r\n## 创建 Repository\r\n\r\n本文以 Docker 默认的 registry，也就是 Docker Hub 为例进行说明。要推送镜像，首先需要在 Docker Hub 上创建一个 Repository。\r\n\r\n1. 访问 [Docker Hub](https://hub.docker.com/) 并登录\r\n2. 点击 **Create Repository** 按钮\r\n3. Repository 名称使用 `todo-app`，将 **Visibility** 设置为 `Public`\r\n4. 点击 **Create** 按钮\r\n\r\n在页面的右侧会看到一个名为 **Docker commands** 的部分。列出了一个示例命令，参考示例命令将自己的镜像推送到仓库。\r\n\r\n![Docker command with push example](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/lidjE1628305471_Docker_command_with_push_example1617268791.png)\r\n\r\n## 推送自己的镜像\r\n\r\n1. 执行 `docker login -u YOUR-USER-NAME` 命令，登录到 Docker Hub\r\n2. 使用 `docker tag` 命令为 `todo-app` 镜像指定一个新名称。确保用您的 Docker ID 替换 `YOUR-USER-NAME`。\r\n   \r\n   ```\r\n   # 用你的 Docker ID 替换 `YOUR-USER-NAME`\r\n   docker tag todo-app YOUR-USER-NAME/todo-app\r\n   ```\r\n3. 使用 `docker push` 推送镜像。如果不指定标签，则 Docker 将默认使用名为 `latest` 的标签\r\n   \r\n   ```\r\n   # 用你的 Docker ID 替换 `YOUR-USER-NAME`\r\n   docker push YOUR-USER-NAME/todo-app\r\n   ```\r\n\r\n## 运行刚刚推送到仓库的镜像\r\n\r\n现在，我们已经将镜像推送到 registry 中，如果其他人要使用我们分享的镜像，就可以通过执行以下命令来使用了：\r\n\r\n```\r\n# 用你的 Docker ID 替换 `YOUR-USER-NAME`\r\ndocker run -dp 3000:3000 YOUR-USER-NAME/todo-app\r\n```\r\n\r\n## 回顾\r\n\r\n在本节中，学习了如何通过将镜像推送到 Docker Hub 这个默认的 registry 来分享我们自己的镜像。\r\n\r\n现在，让我们回过头来看看上一节 `回顾` 中提到的其中一个的小问题：重新启动容器时，会丢失所有待办事项列表数据。下一节将介绍如何解决这个问题。\r\n\r\n> 原始资料：[Sharing Our Application](https://docs.docker.com/get-started/04_sharing_app/)\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,2,1,now(),NULL,NULL),
	(6,'使用 Docker 命名卷 named volume 持久化数据',NULL,'docker-named-volume__doc','到目前为止，使用我们自己创建的镜像启动的容器，每次重启都会清除之前的待办事项数据。为什么会这样？让我们深入研究容器的工作方式。\r\n\r\n## 容器的文件系统\r\n\r\n在之前的章节介绍过，容器运行时使用的是隔离的文件系统，而这个特殊的文件系统就是由 `镜像` 提供的。在一个容器的文件系统上创建/更新/删除文件，都不会影响到另一个容器，即使它们使用的是同一个镜像。\r\n\r\n### 动手验证\r\n\r\n为了验证这一点，我们将启动两个容器，并在其中一个容器中创建一个文件，看看这个文件会不会出现在使用了同一个镜像启动的另一个容器中。\r\n\r\n1. 启动一个 `Ubuntu` 容器，在该容器中创建一个名为 `/data.txt` 的文件，文件内容是 1 到 10000 之间的随机数：\r\n   \r\n   ```\r\n   docker run -d Ubuntu bash -c \"shuf -i 1-10000 -n 1 -o /data.txt && tail -f /dev/null\"\r\n   ```\r\n   \r\n   容器启动之后，开启一个 bash shell 并执行两个命令，`&&` 之前的第一个命令是选择一个 1 到 10000 的随机数，将其写入到 `/ data.txt` 文件中。`&&` 之后的第二个命令只是监视文件以便让容器保持持续运行的状态。\r\n2. 通过 `docker exec` 命令查看容器中 `/data.txt` 文件的内容。\r\n   \r\n   ```\r\n   # 执行上一条 `docker run ...` 命令时输出到控制台的内容就是 <container-id>\r\n   # 也可以通过执行 `docker ps` 获取到 <container-id>\r\n   docker exec <container-id> cat /data.txt\r\n   ```\r\n   \r\n   你应该看到 `/data.txt` 文件的内容了\r\n3. 现在，让我们使用同一个镜像，启动另一个 `ubuntu` 容器，执行以下命令查看新容器的根目录下是否有 `data.txt` 文件：\r\n   \r\n   ```\r\n   docker run -it Ubuntu ls /\r\n   ```\r\n   \r\n   显然并没有看到 `data.txt` 文件，因为它仅被写入第一个容器的暂存空间中，不同容器直接彼此是隔离的。\r\n4. 验证了之后，就可以使用 Docker Desktop 或者使用 `docker rm -f <container-id>` 命令删除之前启动的第一个容器了。\r\n\r\n## 容器的卷 `Volume`\r\n\r\n> 备注：Volume 一般翻译成：卷。但是本文尽量不去翻译这种专有名词，保持英文原文。\r\n\r\n在之前的实验中，我们看到每个容器每次启动都从镜像的定义中重新开始创建容器的文件系统。尽管容器可以创建、更新和删除文件，但是当容器被删除或者重新启动时，之前创建或修改的文件都将丢失。使用 `Volume`，可以改变目前的现状。\r\n\r\n[Volumes](https://docs.docker.com/storage/volumes/) 提供将容器的特定文件系统路径连接回主机的功能。如果容器中的一个目录被挂载，那么这个目录的修改同样能够在主机上被看到。如果在重新启动容器时挂载了相同的目录，就能够看到相同的文件了。\r\n\r\n> 备注：这里说的 `主机` 或者 `本机` 指的是运行 Docker 引擎的这台机器，也就是我们的 Mac、Windows 或者 Linux 机器。\r\n\r\n`volumes` 有两种类型，先从开始 **named volumes** 介绍。同样的，这里的 `named volumes` 一般翻译成 `命名卷`，但是在后续的章节中，我们也尽量不去翻译它。\r\n\r\n## 保存我们的待办事项数据\r\n\r\n默认情况下，我们的 `todo-app` 应用程序使用的是 [SQLite 数据库](https://www.sqlite.org/index.html) 将数据存储在 `/etc/todos/todo.db` 文件中。如果你不熟悉 SQLite，不用担心！它跟 MySQL 类似都属于关系型数据库，但是 `SQLite` 更简单一些，它将所有数据都存储在一个文件中。虽然这对于大型应用程序不是最佳选择，但对于小型演示型应用却很适合。稍后我们会讨论如何将它切换到其他数据库引擎，比如 MySQL 数据库。\r\n\r\n由于我们要用数据库是单个文件，因此我们可以将这个文件保存在主机上，然后创建一个 `volume`，将主机上的这个文件与容器中的某个位置关联在一起，这样就可以解决重启或者在新启动容器出现的数据丢失问题了。\r\n\r\n如前所述，我们将使用 **named volume** 来实现这个功能，可以将 **named volume** 视为简单的数据桶。 Docker 维护主机上的物理位置，你只需要记住 `volume` 的名称即可。每次使用该 `volume` 时，Docker 将确保提供正确的数据。\r\n\r\n1. 使用 `docker volume create` 命令创建 `volume`\r\n   ```\r\n   # 也可以不用主动创建，当执行下方第 3 步的时候，Docker 会自动检测我们指定的 volume 是否存在，如果不存在会自动帮我们创建\r\n   docker volume create todo-db\r\n   ```\r\n2. 通过 Docker Dashboard 或者使用 `docker rm -f <container-id>` 命令停止并删除正在运行中的 `todo-app` 应用程序容器\r\n3. 再次启动容器, 但是这次要添加 `-v` 标志以指定要挂载的 `volume`。我们将使用 `named volume` 并将其挂载到容器上的 `/etc/todos` 路径下，这个 `named volume` 将会感知在这个路径下创建的所有文件。\r\n   ```\r\n   docker run -dp 3000:3000 -v todo-db:/etc/todos todo-app\r\n   ```\r\n4. 容器启动后，访问我们的应用程序并添加一些待办事项\r\n   ![Items added to todo list](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/W8fmo1628305546_Items_added_to_todo_list1617269932.png)\r\n5. 参考第 2 步，再一次删除正在运行的容器\r\n6. 参考第 3 步，再一次启动容器\r\n7. 访问我们的应用，验证是否还能看到之前添加的待办事项\r\n\r\n## 深入看一看 Volume\r\n\r\n很多人经常问：“当我使用 `named volume` 时，Docker 实际上在哪里存储数据？”\r\n如果你想知道答案，可以使用 `docker volume inspect ...` 命令查看 volume 的详细信息。\r\n\r\n```\r\ndocker volume inspect todo-db\r\n\r\n[\r\n    [\r\n        \"CreatedAt\" => \"2021-01-12T03:35:55Z\",\r\n        \"Driver\" => \"local\",\r\n        \"Labels\" => null,\r\n        \"Mountpoint\" => \"/var/lib/docker/volumes/todo-db/_data\",\r\n        \"Name\" => \"todo-db\",\r\n        \"Options\" => null,\r\n        \"Scope\" => \"local\"\r\n    ]\r\n]\r\n```\r\n\r\n`Mountpoint` 的值就是主机上存储数据的实际位置。需要注意的是，在大多数计算机上，需要具有 root 访问权限的用户才能在主机上访问此目录。\r\n\r\n## 回顾\r\n\r\n这一节，我们学会了如何为容器持久化存储数据了。\r\n\r\n下一节，将介绍如何使用另外一种 `volume` 类型：`bind mounts` 及时让容器感知到主机上源代码的变动。\r\n\r\n> 原始资料：[Persisting our DB](https://docs.docker.com/get-started/05_persisting_data/)\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,3,1,now(),NULL,NULL),
	(7,'使用 bind mounts 快速搭建本地开发环境',NULL,'docker-bind-mounts__doc','在上一节中，我们讨论并使用了 **named volume** 将数据持久保存在数据库中。如果我们只想简单的存储数据，那么 **named volume** 就够用了，因为我们不必关心数据的存储位置。\r\n\r\n这一节，将在介绍另外一种 `volume` 类型，即：`bind mounts`\r\n使用 **bind mounts** 我们可以控制主机上的准确挂载点。虽然也可以用它来保存数据，但是通常是用它来向容器提供额外数据。比如：我们可以使用 **bind mounts** 将主机上的源代码挂载到容器中，以便容器可以及时感知源代码的变更。\r\n\r\n对于基于 Node.js 的应用程序，[nodemon]（https://npmjs.com/package/nodemon）是监视文件更改然后重新启动应用程序的好工具。大多数其他语言和框架都有类似的工具。\r\n\r\n## 两种不同 Volume 类型的比较\r\n\r\n`named volumes` 和 `bind mounts` 是 Docker 引擎内置的两种主要 `Volume` 类型。也可以使用其他类型的 Volume 驱动程序来支持其他使用场景，如 [SFTP](https://github.com/vieux/docker-volume-sshfs)、[Ceph](https://ceph.com/geen-categorie/getting-started-with-the-docker-rbd-volume-plugin/)、[NetApp](https://netappdvp.readthedocs.io/en/stable/)、[S3](https://github.com/elementar/docker-s3-volume) 等...\r\n\r\n|                                              | Named Volumes             | Bind Mounts                   |\r\n| ---------------------------------------------- | --------------------------- | ------------------------------- |\r\n| 在主机上的位置                               | 由 Docker 自动选择            | 由你自己决定                  |\r\n| 挂载示例 (使用 `-v` 标记)               | my-volume:/usr/local/data | /path/to/data:/usr/local/data |\r\n| 使用容器内容填充新 volume | 是                       | 否                            |\r\n| 支持 Volume 驱动程序                    | 是                       | 否                            |\r\n\r\n## 启动一个开发模式的容器\r\n\r\n为了运行一个支持开发工作流程的容器，我们将执行以下操作：\r\n\r\n* 将我们的源代码挂载到容器中\r\n* 安装所有依赖项，包括 `dev` 依赖项\r\n* 启动 `nodemon` 来监听文件变化\r\n\r\n让我们开始吧：\r\n\r\n1. 删除之前启动的 `todo-app` 容器\r\n2. 执行以下命令：\r\n   \r\n   ```\r\n   docker run -dp 3000:3000 \\\r\n       -w /app \\\r\n       -v \"$(pwd):/app\" \\\r\n       node:12-alpine \\\r\n       sh -c \"yarn install && yarn run dev\"\r\n   ```\r\n   \r\n   如果使用的是 PowerShell，执行下面这条命令（只是 `多行输入` 的分隔符不一样而已）\r\n   \r\n   ```\r\n   docker run -dp 3000:3000 `\r\n       -w /app `\r\n       -v \"$(pwd):/app\" `\r\n       node:12-alpine `\r\n       sh -c \"yarn install && yarn run dev\"\r\n   ```\r\n   \r\n   * `-dp 3000:3000` - 之前遇到过了，表示让容器保持在后台运行并做好端口映射\r\n   * `-w /app` - 设置 \"working directory\" - 工作目录\r\n   * `-v \"$(pwd):/app\"` - `bind mount` 主机上的当前目录挂载到容器上的 `/app` 目录\r\n   * `node:12-alpine` - 使用的镜像\r\n   * `sh -c \"yarn install && yarn run dev\"` - 在容器中执行两条命令。由于 alpine 没有 bash，所以通过 sh 执行这两条命令，第一条：`yarn install` 安装我们程序用到的依赖；第二条：`yarn run dev` 启动服务。如果我们查看 `package.json` 文件就会发现 `dev` 脚本正是使用能够监听文件变化并自动重启服务的 `nodemon`（一旦主机上的源码有变化，它能及时监听到，并自动重启 todo-app 服务）\r\n3. 由于上一条命令会在容器中执行安装依赖的操作，在不同的网络环境下的执行时间可能快也可能慢，因此需要等待一会才能访问我们的服务。可以通过 `docker logs` 命令查看容器日志，先执行 `docker image ls` 查看容器 ID，再执行 `docker logs -f <container-id>` 命令，如果看到日志输出了 `Listening on port 3000` 就代表我们的程序已经启动成功。\r\n   \r\n   ```\r\n   docker logs -f <container-id>\r\n   \r\n   yarn install ...\r\n   [1/4] Resolving packages...\r\n   [2/4] Fetching packages...\r\n   ......\r\n   [3/4] Linking dependencies...\r\n   [4/4] Building fresh packages...\r\n   Done in 93.42s.\r\n   ......\r\n   $ nodemon src/index.js\r\n   [nodemon] 1.19.2\r\n   [nodemon] to restart at any time, enter `rs`\r\n   [nodemon] watching dir(s): *.*\r\n   [nodemon] starting `node src/index.js`\r\n   Using SQLite database at /etc/todos/todo.db\r\n   Listening on port 3000\r\n   ```\r\n   \r\n   看完日志后，按 `Ctrl + C` 退出。\r\n4. 现在，让我们来再一次修改源代码。将 `src/static/js/app.js` 文件第 109 行的 \"Add Item\" 改成 \"Add\"\r\n5. 只需刷新应用的首页，几乎就能立即在浏览器中看到更改。容器内部自动重新启动 Node 服务器可能需要花费几秒钟的时间，因此，如果访问页面出现错误，可以稍等几秒钟后再试。\r\n   ![Screenshot of updated label for Add button](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/kiT3b1628305588_Screenshot_of_updated_label_for_Add_button1617270009.png)\r\n6. 至此，你可以随时在本机对应用程序源码进行任何更改。完成后，停止容器并使用 `docker build -t todo-app .` 重新构建新镜像。\r\n   在本地开发模式下，使用 `bind mounts` 非常普遍。它的优点是使得本地开发机器不需要安装所有构建工具和环境。只需一条 docker run 命令，开发环境就准备就绪了。\r\n\r\n## 回顾\r\n\r\n本节我们学习了如何通过 `bind mounts` 快速搭建本地开发环境。\r\n\r\n下一节我们准备将数据库从 SQLite 改成更适合生产环境使用的 MySQL。那么问题来了，我们该如何运行 MySQL? 如何让不同容器之间彼此通信？下节再详细说明。\r\n\r\n> 原始资料：[Using Bind Mounts](https://docs.docker.com/get-started/06_bind_mounts/)\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,3,1,now(),NULL,NULL),
	(8,'Docker 多容器应用 Multi-Container Apps',NULL,'docker-multi-container-apps__doc','到目前为止，我们一直在使用单个容器应用程序。但是，我们现在想将 MySQL 添加到应用程序架构中。那么，问题来了：MySQL 将在哪里运行？是将它安装在同一容器中还是在另外的单独容器中运行？\r\n一般来说，**一个容器应该只做一件事。** 原因：\r\n\r\n* 虽然你可以在开发阶段使用本地数据库，但是很可能要在生产环境中使用云数据库。所以，将数据库与应用程序运行在同一个容器中不太合适。\r\n* 一般情况下，一个容器应该仅启动一个进程，如果在同一个容器中运行多个进程会增加容器启动/关闭/服务运行情况监听的复杂性。\r\n\r\n还有其他更多原因。因此，我们会新启动一个容器运行 MySQL 服务，结构如下：\r\n\r\n![Todo App connected to MySQL container](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/OZc3z1628305632_Todo_App_connected_to_MySQL_container1617270064.png)\r\n\r\n## 容器 Networking\r\n\r\n默认情况下，容器是独立运行的，并且对同一台主机上的其他进程或容器一无所知。So, how do we allow one container to talk to another? The answer is **networking**. Now, you don\'t have to be a network engineer (hooray!). Simply remember this rule...那么，我们如何允许一个容器与另一个容器对话？答案是通过 **networking** - 网络。你不必具备网络工程师的知识，只需要记住一个最简单的规则就够用了：`如果两个容器在同一个网络中，它们就可以相互通信。否则，就不行`\r\n\r\n## 启动 MySQL\r\n\r\n接着就让我们将 `todo-app` 与 `MySQL` 这两个容器放在同一个网络中：\r\n\r\n1. 创建网络\r\n   \r\n   ```\r\n   docker network create todo-app\r\n   ```\r\n2. 启动 MySQL 容器并为它指定网络。我们还设置了一些环境变量的值，MySQL 将使用这些变量来初始化数据库，它支持的所有环境变量可以查看 [MySQL 镜像的说明](https://hub.docker.com/_/mysql/)\r\n   \r\n   ```\r\n   docker run -d \\\r\n       --network todo-app --network-alias MySQL \\\r\n       -v todo-mysql-data:/var/lib/mysql \\\r\n       -e MYSQL_ROOT_PASSWORD=secret \\\r\n       -e MYSQL_DATABASE=todos \\\r\n       mysql:5.7\r\n   ```\r\n   \r\n   如果使用的是 PowerShell，执行下面这条命令（只是 `多行输入` 的分隔符不一样而已）\r\n   \r\n   ```\r\n   docker run -d `\r\n       --network todo-app --network-alias MySQL `\r\n       -v todo-mysql-data:/var/lib/mysql `\r\n       -e MYSQL_ROOT_PASSWORD=secret `\r\n       -e MYSQL_DATABASE=todos `\r\n       mysql:5.7\r\n   ```\r\n   \r\n   你应该看到了，我们增加了 `--network-alias` 标记，稍后再讨论它。\r\n   \r\n   > 备注：\r\n   > 这条命令还通过 `-v` 标记使用了名字为 `todo-mysql-data` 的 `volume` 并将它挂载到 `/var/lib/mysql` 路径下，也就是 MySQL 真正存储数据的地方。虽然我们没有先执行 `docker volume create` 命令提前创建 `volume` 但是 Docker 识别到我们要用 `named volume`，并自动为我们创建了一个。\r\n3. 为了确认数据库是否已经启动成功，可以使用以下命令连接到数据库容器，验证是否能连接成功。\r\n   \r\n   ```\r\n   docker exec -it <mysql-container-id> MySQL -p\r\n   ```\r\n   \r\n   出现输入密码的界面时，输入上一条命令指定的 **MYSQL_ROOT_PASSWORD** 环境变量的值 `secret`\r\n   成功进入 MySQL 之后，执行以下命令列出所有数据库\r\n   \r\n   ```\r\n   mysql> SHOW DATABASES;\r\n   ```\r\n   \r\n   你应该能看到如下所示的输出：\r\n   \r\n   ```\r\n   +--------------------+\r\n   | Database           |\r\n   +--------------------+\r\n   | information_schema |\r\n   | MySQL              |\r\n   | performance_schema |\r\n   | sys                |\r\n   | todos              |\r\n   +--------------------+\r\n   5 rows in set (0.00 sec)\r\n   ```\r\n\r\n## 连接到 MySQL\r\n\r\nMySQL 已启动成功，让我们使用它吧！但是，问题是...怎么用？如果我们在同一个网络上运行另一个容器，如何找到该容器？\r\n\r\n为了弄清楚这一点，我们将使用 [nicolaka/netshoot](https://github.com/nicolaka/netshoot) 容器, 它内置*大量*可用于对网络问题进行故障排除或调试的工具。\r\n\r\n1. 使用 nicolaka/netshoot 镜像启动一个新容器。确保将它连接到同一个网络上\r\n   \r\n   ```\r\n   docker run -it --network todo-app nicolaka/netshoot\r\n   ```\r\n2. 在容器内部，我们将使用 `dig` 命令，这是一个有用的 DNS 工具。我们将查找主机名 `mysql` 的 IP 地址\r\n   \r\n   ```\r\n   dig MySQL\r\n   ```\r\n   \r\n   将会看到类似如下的输出...\r\n   \r\n   ```\r\n   ; <<>> DiG 9.14.1 <<>> MySQL\r\n   ;; global options: +cmd\r\n   ;; Got answer:\r\n   ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 32162\r\n   ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\r\n   \r\n   ;; QUESTION SECTION:\r\n   ;mysql.             IN  A\r\n   \r\n   ;; ANSWER SECTION:\r\n   mysql.          600 IN  A   172.18.0.2\r\n   \r\n   ;; Query time: 0 msec\r\n   ;; SERVER: 127.0.0.11#53(127.0.0.11)\r\n   ;; WHEN: Wed Jan 13 05:21:49 UTC 2021\r\n   ;; MSG SIZE  rcvd: 44\r\n   ```\r\n   \r\n   在 \"ANSWER SECTION\" 应答部分，会看到 `mysql` 的 A 记录，解析为 172.18.0.2（你看到的 IP 地址很可能跟我不一样）。虽然 `mysql` 通常不是有效的主机名，但 Docker 能够将其解析为具有该网络别名的容器的 IP 地址（还记得我们之前在启动 MySQL 容器时使用的 `--network-alias` 标志吗？它的作用就是为这个容器主机取一个别名）。这意味着...我们的应用程序仅需连接到名为 `mysql` 的主机，就能跟数据库对话了，就是这么简单！\r\n\r\n## 使用 MySQL 运行我们的应用\r\n\r\n我们的 todo-app 应用程序支持一些环境变量的设置，以指定 MySQL 连接设置。它们是：\r\n\r\n* `MYSQL_HOST` - MySQL 服务器的主机名\r\n* `MYSQL_USER` - 用于连接的用户名\r\n* `MYSQL_PASSWORD` - 用于连接的密码\r\n* `MYSQL_DB` - 连接后要使用的数据库\r\n\r\n> 重要提醒：\r\n> 直接通过在命令行中设置环境变量的做法，在本地开发模式下没什么问题，但是 `强烈反对` 在生产环境中使用。Docker 前安全负责人 Diogo Monica，[撰写了一篇精彩的博客文章](https://diogomonica.com/2017/03/27/why-you-shouldnt-use-env-variables-for-secret-data/) 详细解释了反对的原因。\r\n> 一种更安全的机制是使用 `container orchestration framework` 提供的安全支持。在大多数情况下，这些密码会作为文件挂载到正在运行的容器中。你会看到许多应用程序（包括 MySQL 镜像和 我们自己的 todo-app 应用程序）也支持带有 `_FILE` 后缀的环境变量以指向包含真正环境变量的文件。 例如，设置 `MYSQL_PASSWORD_FILE` 变量，这个变量指向的文件内容将被作为 `MYSQL_PASSWORD` 的值，即，真正的连接密码。Docker 默认不支持这种环境变量，你的应用需要自己清楚如何寻找变量并获取文件内容。\r\n\r\n在解释了所有这些内容之后，让我们利用刚刚掌握的知识启动一个新容器：\r\n\r\n1. 我们将指定 `todo-app` 应用程序需要用到的几个环境变量，并将容器连接到我们的应用程序网络上\r\n   \r\n   ```\r\n   # 确保在本机的 app 目录下执行以下命令\r\n   docker run -dp 3000:3000 \\\r\n     -w /app \\\r\n     -v \"$(pwd):/app\" \\\r\n     --network todo-app \\\r\n     -e MYSQL_HOST=mysql \\\r\n     -e MYSQL_USER=root \\\r\n     -e MYSQL_PASSWORD=secret \\\r\n     -e MYSQL_DB=todos \\\r\n     node:12-alpine \\\r\n     sh -c \"yarn install && yarn run dev\"\r\n   ```\r\n   \r\n   如果使用的是 PowerShell，执行下面这条命令（只是 `多行输入` 的分隔符不一样而已）\r\n   \r\n   ```\r\n   docker run -dp 3000:3000 `\r\n     -w /app `\r\n     -v \"$(pwd):/app\" `\r\n     --network todo-app `\r\n     -e MYSQL_HOST=mysql `\r\n     -e MYSQL_USER=root `\r\n     -e MYSQL_PASSWORD=secret `\r\n     -e MYSQL_DB=todos `\r\n     node:12-alpine `\r\n     sh -c \"yarn install && yarn run dev\"\r\n   ```\r\n2. 通过查看容器的日志（`docker logs <container-id>`），应该能看到类似 `Connected to MySQL db at host mysql` 的日志输出，代表我们的应用程序现在就是使用 MySQL 数据库来保存数据了。\r\n   \r\n   ```\r\n   # 省略之前的日志消息 ...\r\n   $ nodemon src/index.js\r\n   [nodemon] 1.19.2\r\n   [nodemon] to restart at any time, enter `rs`\r\n   [nodemon] watching dir(s): *.*\r\n   [nodemon] starting `node src/index.js`\r\n   Connected to MySQL db at host MySQL\r\n   Listening on port 3000\r\n   ```\r\n3. 访问我们的应用程序，然后添加一些待办事项\r\n4. 连接到 MySQL 数据库并证明这些待办事项已被写入到 MySQL 数据库。记住，密码是 **secret**\r\n   \r\n   ```\r\n   docker exec -it <mysql-container-id> MySQL -p todos\r\n   ```\r\n   \r\n   进入 MySQL 之后执行以下命令：\r\n   \r\n   ```\r\n   mysql> select * from todo_items;\r\n   +--------------------------------------+--------------------+-----------+\r\n   | id                                   | name               | completed |\r\n   +--------------------------------------+--------------------+-----------+\r\n   | c906ff08-60e6-44e6-8f49-ed56a0853e85 | Do amazing things! |         0 |\r\n   | 2912a79e-8486-4bc3-a4c5-460793a575ab | Be awesome!        |         0 |\r\n   +--------------------------------------+--------------------+-----------+\r\n   ```\r\n   \r\n   很显然，你的表数据跟我的不一样，因为它保存的是你刚刚输入的待办事项。但是，你应该能看到它们被存储在这里了！\r\n\r\n如果你现在打开 Docker Dashboard 将会看到有两个正在运行的应用程序容器，其中一个是 MySQL 容器，另一个是我们的 todo-app 应用。但是，它们现在看起来好像没有任何关系。\r\n\r\n![Docker Dashboard showing two ungrouped app containers](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/NQEE81628305632_Docker_Dashboard_showing_two_ungrouped_app_containers1617270065.png)\r\n\r\n## 回顾\r\n\r\n至此，我们有了一个应用程序，它现在将其数据存储在单独运行的数据库容器中。\r\n\r\n但是，要启动整个程序有点麻烦，我们必须创建一个网络，启动多个容器，指定所有环境变量，映射端口等等！这样复杂的步骤既不利于自己使用也不方便分享给其他人使用。\r\n\r\n在下一节中，我们将讨论 Docker Compose。借助 Docker Compose 可以以一种更简单的方式分享我们的应用，并允许其他人只使用一个简单的命令就可以将它们运行起来！\r\n\r\n> 原始资料：[Multi-Container Applications](https://docs.docker.com/get-started/07_multi_container/)\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,3,1,now(),NULL,NULL),
	(9,'使用 Docker Compose',NULL,'using-docker-compose__doc','[Docker Compose](https://docs.docker.com/compose/) 是一款旨在帮助定义和共享多容器应用程序的工具。通过 Compose，我们可以创建一个 YAML 文件来定义需要使用的所有服务，并且只需要一个命令就可以启动或停止所有服务。\r\n\r\n使用 Compose 的最大优点是你只需在一个文件中定义自己的应用程序栈（即应用程序需要用到的所有服务），然后把这个 YAML 文件放在项目的根目录下，与源码一起受版本控制。其他人只需 clone 你的项目源码之后就可以快速启动服务。实际上，在 GitHub 或 GitLab 上已经有很多项目正在这样做。\r\n\r\n我们也来为 todo 应用创建一个 YAML 文件吧。\r\n\r\n## 安装 Docker Compose\r\n\r\n如果你使用的是 Windows 或者 Mac 桌面操作系统，在安装 Docker Desktop 之后就已经内置了 Docker Compose。如果你使用的是 Linux 系统，可以参照 [此处的说明](https://docs.docker.com/compose/install/) 安装 Docker Compose\r\n\r\n安装完成之后，可以执行以下命令查看它的版本信息：\r\n\r\n```\r\ndocker-compose version\r\n```\r\n\r\n## 创建我们的 Compose 文件\r\n\r\n1. 在 `todo-app` 项目的根目录下，创建一个名为 `docker-compose.yml` 的文件\r\n2. 在 `docker-compose.yml` 文件的第一行定义 schema version。在大多数情况下，最好使用最新的受支持 schema version。你可以查看 [Compose file reference](https://docs.docker.com/compose/compose-file/) 以获得最新的 schema version 和兼容性列表。\r\n   ```\r\n   version: \"3.7\"\r\n   ```\r\n3. 接下来，我们将定义 `todo-app` 应用程序依赖的一系列服务（或容器）列表。\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n   ```\r\n\r\n接着，我们开始将之前通过命令行执行的命令，翻译成 compose 文件支持的格式。\r\n\r\n## 定义 `todo-app` 应用服务\r\n\r\n回顾一下之前使用过的命令：\r\n\r\n```\r\ndocker run -dp 3000:3000 \\\r\n  -w /app \\\r\n  -v \"$(pwd):/app\" \\\r\n  --network todo-app \\\r\n  -e MYSQL_HOST=mysql \\\r\n  -e MYSQL_USER=root \\\r\n  -e MYSQL_PASSWORD=secret \\\r\n  -e MYSQL_DB=todos \\\r\n  node:12-alpine \\\r\n  sh -c \"yarn install && yarn run dev\"\r\n```\r\n\r\n如果使用的是 PowerShell，之前使用的是下面这条命令（只是 `多行输入` 的分隔符不一样而已）\r\n\r\n```\r\ndocker run -dp 3000:3000 `\r\n  -w /app `\r\n  -v \"$(pwd):/app\" `\r\n  --network todo-app `\r\n  -e MYSQL_HOST=mysql `\r\n  -e MYSQL_USER=root `\r\n  -e MYSQL_PASSWORD=secret `\r\n  -e MYSQL_DB=todos `\r\n  node:12-alpine `\r\n  sh -c \"yarn install && yarn run dev\"\r\n```\r\n\r\n1. 首先，定义 `todo-app` 应用服务名称和使用的镜像，可以为它取任何名称，这里简单取成同名 `todo-app`。该名称将自动作为网络的别名，在后续定义 MySQL 服务时将很有用。\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       image: node:12-alpine\r\n   ```\r\n2. 接着我们把容器启动之后要执行的命令写在靠近定义 `image` 的地方，尽管不一定按照这样的顺序书写，但是通常都这样做。类似下面这样：\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       image: node:12-alpine\r\n       command: sh -c \"yarn install && yarn run dev\"\r\n   ```\r\n3. 接着定义端口映射\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       image: node:12-alpine\r\n       command: sh -c \"yarn install && yarn run dev\"\r\n       ports:\r\n         - 3000:3000\r\n   ```\r\n4. 再来将 `-w /app` **工作目录** 和 `-v \"$(pwd):/app\"` **volume** 通过 `working_dir` 和 `volumes` 这两个属性来定义。\r\n   在 Docker Compose 配置文件中定义 volume 的一个优点是我们可以使用基于 `docker-compose.yml` 文件所在目录的相对路径。\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       image: node:12-alpine\r\n       command: sh -c \"yarn install && yarn run dev\"\r\n       ports:\r\n         - 3000:3000\r\n       working_dir: /app\r\n       volumes:\r\n         - ./:/app\r\n   ```\r\n5. 最后，通过 `environment` 定义 `todo-app` 需要使用到的环境变量。\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       image: node:12-alpine\r\n       command: sh -c \"yarn install && yarn run dev\"\r\n       ports:\r\n         - 3000:3000\r\n       working_dir: /app\r\n       volumes:\r\n         - ./:/app\r\n       environment:\r\n         MYSQL_HOST: MySQL\r\n         MYSQL_USER: root\r\n         MYSQL_PASSWORD: secret\r\n         MYSQL_DB: todos\r\n   ```\r\n\r\n### 定义 MySQL 服务\r\n\r\n现在，是时候定义 MySQL 服务了。同样先回顾之前启动 MySQL 容器时使用的命令：\r\n\r\n```\r\ndocker run -d \\\r\n  --network todo-app --network-alias MySQL \\\r\n  -v todo-mysql-data:/var/lib/mysql \\\r\n  -e MYSQL_ROOT_PASSWORD=secret \\\r\n  -e MYSQL_DATABASE=todos \\\r\n  mysql:5.7\r\n```\r\n\r\n如果使用的是 PowerShell，之前使用的是下面这条命令（只是 `多行输入` 的分隔符不一样而已）\r\n\r\n```\r\ndocker run -d `\r\n  --network todo-app --network-alias MySQL `\r\n  -v todo-mysql-data:/var/lib/mysql `\r\n  -e MYSQL_ROOT_PASSWORD=secret `\r\n  -e MYSQL_DATABASE=todos `\r\n  mysql:5.7\r\n```\r\n\r\n1. 先定义一个新服务并将它命名为 `mysql`，接着指定该服务使用的镜像。\r\n   \r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       # The app service definition\r\n     mysql:\r\n       image: mysql:5.7\r\n   ```\r\n2. 接着定义 `named volume` 的映射关系。当我们使用 `docker run` 运行容器时，Docker 会自动创 `named volume`。但是，使用 Compose 运行时不会自动创建，所以我们需要在配置文件的顶层使用 `volumes` 属性定义 `named volume`，然后在 MySQL 服务下的 `volumes` 指定它的实际挂载点。\r\n   \r\n   > 备注：这两个 `volumes` 出现的位置不一样。第一个是在 compose 文件的顶层，另外一个是在 MySQL 这个服务之下。\r\n   \r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n     # The app service definition\r\n   mysql:\r\n     image: mysql:5.7\r\n   volumes:\r\n     - todo-mysql-data:/var/lib/mysql\r\n   \r\n   volumes:\r\n   todo-mysql-data:\r\n   ```\r\n3. 最后，指定启动 MySQL 服务需要的环境变量\r\n   \r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       # The app service definition\r\n     mysql:\r\n       image: mysql:5.7\r\n       volumes:\r\n         - todo-mysql-data:/var/lib/mysql\r\n       environment: \r\n         MYSQL_ROOT_PASSWORD: secret\r\n         MYSQL_DATABASE: todos\r\n   \r\n   volumes:\r\n     todo-mysql-data:\r\n   ```\r\n\r\n此时，完整的 `docker-compose.yml` 看起来像这样：\r\n\r\n```\r\nversion: \"3.7\"\r\n\r\nservices:\r\n  todo-app:\r\n    image: node:12-alpine\r\n    command: sh -c \"yarn install && yarn run dev\"\r\n    ports:\r\n      - 3000:3000\r\n    working_dir: /app\r\n    volumes:\r\n      - ./:/app\r\n    environment:\r\n      MYSQL_HOST: MySQL\r\n      MYSQL_USER: root\r\n      MYSQL_PASSWORD: secret\r\n      MYSQL_DB: todos\r\n\r\n  mysql:\r\n    image: mysql:5.7\r\n    volumes:\r\n      - todo-mysql-data:/var/lib/mysql\r\n    environment: \r\n      MYSQL_ROOT_PASSWORD: secret\r\n      MYSQL_DATABASE: todos\r\n\r\nvolumes:\r\n  todo-mysql-data:\r\n```\r\n\r\n## 启动我们的完整应用\r\n\r\n现在我们已经有了 `docker-compose.yml` 文件，就可以启动它了！\r\n\r\n1. 确保之前通过命令行启动的应用和 MySQL 容器已经停止并删除了。如何还运行着，可以通过 Docker Desktop 或者使用 docker ps 配合 docker rm -f <container-ids> 删除它们。\r\n2. 使用 `docker-compose up` 命令启动应用程序栈（`todo-app` + `mysql`）。添加 `-d` 标志可以让它们保持在后台运行。\r\n   \r\n   ```\r\n   docker-compose up -d\r\n   ```\r\n   \r\n   运行此命令之后，应看到如下输出：\r\n   \r\n   ```\r\n   Creating network \"app_default\" with the default driver\r\n   Creating volume \"app_todo-mysql-data\" with default driver\r\n   Creating app_todo-app_1   ... done\r\n   Creating app_mysql_1 ... done\r\n   ```\r\n   \r\n   你应该已经注意到了，`volume` 和 `network` 都已经已创建成功。默认情况下，Docker Compose 会自动为应用程序栈自动创建一个网络，这就是为什么我们没有在 compose 文件中显式定义网络的原因。\r\n3. 让我们使用 `docker-compose logs -f` 命令查看日志。每个服务的日志汇总统一输出在这里。`-f` 标志用于实时输出日志。\r\n   \r\n   如果要查看特定服务的日志，可以将服务名称添加到 logs 命令的末尾（例如 `docker-compose logs -f mysql`）。\r\n4. 至此，只用了一个命令就可以启动我们应用程序需要的所有服务了。\r\n\r\n## 在 Docker Dashboard 中查看我们的应用程序栈\r\n\r\n如果现在查看 Docker Dashboard，将会看到有一个名为 `app` 的组，将所有使用到的容器组在一起了。默认情况下，项目名称是 `docker-compose.yml` 文件所在目录的名称。\r\n\r\n![Docker Dashboard with app project](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/6rTMo1628305678_Docker_Dashboard_with_app_project1617270116.png)\r\n\r\n如果点击 `app` 这个分组，将会看到我们在 `docker-compose.yml` 文件中定义的两个容器。名称也更具描述性，因为它们遵循 `< 项目名称 >_< 服务名称 >_< 副本编号 >` 的格式。因此，可以很方便的查看哪个容器是我们的 `todo` 服务以及哪个容器是 MySQL 数据库服务。\r\n\r\n![Docker Dashboard with app project expanded](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/Zdsmk1628305678_Docker_Dashboard_with_app_project_expanded1617270117.png)\r\n\r\n## 删除所有容器\r\n\r\n如果要将它们全部删除，只需运行 `docker-compose down` 或在 Docker Dashboard 上点击垃圾桶图标即可。同时也会删除自动创建的网络。\r\n\r\n删除 Volumes\r\n默认情况下，运行 `docker-compose down` 命令，不会自动删除 `docker-compose.yml` 文件中定义的 `named volumes`。如果要删除 volumes，只需添加 `--volumes` 标志即可。\r\n\r\n## 回顾\r\n\r\n在本节中，我们学习了如何利用 Docker Compose 帮助我们极大简化多服务应用程序的定义和分享。我们把之前使用的命令转换为对应的 compose 格式，写入新创建的 `docker-compose.yml` 文件中。然后，就可以只使用一条命令启动或者删除所有服务了。\r\n\r\n下一节让我们更进一步，介绍一些构建镜像的最佳实践。\r\n\r\n> 原始资料：[Using Docker Compose](https://docs.docker.com/get-started/08_using_compose/)\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,3,1,now(),NULL,NULL),
	(10,'构建 Docker 镜像的最佳实践',NULL,'docker-image-building-best-practices__doc','## 安全扫描\r\n\r\n镜像构建完成之后，最好使用 `docker scan` 命令对其进行扫描以查找安全漏洞。Docker 与 [Snyk](http://snyk.io/) 合作提供漏洞扫描服务。\r\n\r\n例如，要扫描我们自己创建的 `todo-app` 镜像，只需执行以下命令：\r\n\r\n```\r\ndocker scan todo-app\r\n```\r\n\r\n扫描命令使用了一个不断更新的漏洞数据库，如果没有发现漏洞，类似如下输出：\r\n\r\n```\r\n➜  ~ docker scan todo-app\r\nDocker Scan relies upon access to Snyk, a third party provider, do you consent to proceed using Snyk? (y/N)\r\ny\r\n\r\nTesting todo-app...\r\n...\r\n\r\n✓ Tested 16 dependencies for known vulnerabilities, no vulnerable paths found.\r\n\r\nFor more free scans that keep your images secure, sign up to Snyk at https://dockr.ly/3ePqVcp\r\n\r\n➜  ~\r\n```\r\n\r\n如果发现了漏洞，类似如下输出：\r\n\r\n```\r\n✗ Low severity vulnerability found in freetype/freetype\r\n  Description: CVE-2020-15999\r\n  Info: https://snyk.io/vuln/SNYK-ALPINE310-FREETYPE-1019641\r\n  Introduced through: freetype/freetype@2.10.0-r0, gd/libgd@2.2.5-r2\r\n  From: freetype/freetype@2.10.0-r0\r\n  From: gd/libgd@2.2.5-r2 > freetype/freetype@2.10.0-r0\r\n  Fixed in: 2.10.0-r1\r\n\r\n✗ Medium severity vulnerability found in libxml2/libxml2\r\n  Description: Out-of-bounds Read\r\n  Info: https://snyk.io/vuln/SNYK-ALPINE310-LIBXML2-674791\r\n  Introduced through: libxml2/libxml2@2.9.9-r3, libxslt/libxslt@1.1.33-r3, nginx-module-xslt/nginx-module-xslt@1.17.9-r1\r\n  From: libxml2/libxml2@2.9.9-r3\r\n  From: libxslt/libxslt@1.1.33-r3 > libxml2/libxml2@2.9.9-r3\r\n  From: nginx-module-xslt/nginx-module-xslt@1.17.9-r1 > libxml2/libxml2@2.9.9-r3\r\n  Fixed in: 2.9.9-r4\r\n```\r\n\r\n列出了漏洞类型、了解更多信息的 URL 等等，最重要的是哪个版本修复了该漏洞，以便我们及时更新到安全的版本。\r\n\r\n更多关于漏洞扫描的信息可以查看 [docker scan documentation](https://docs.docker.com/engine/scan/)\r\n\r\n除了在命令行上扫描新生成的镜像外，还可以 [配置 Docker Hub](https://docs.docker.com/docker-hub/vulnerability-scanning/) 来自动扫描所有新推送的镜像，然后在 Docker Hub 和 Docker Desktop 中查看安全扫描结果。类似下图的显示：\r\n\r\n![Hub vulnerability scanning](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/zoKGp1628305754_Hub_vulnerability_scanning1617270166.png)\r\n\r\n## 镜像分层\r\n\r\n1. 可以通过 `docker image history` 命令查看镜像的创建历史，镜像中每个图层的都执行了哪些命令。\r\n\r\n```bash\r\ndocker image history todo-app\r\n```\r\n\r\n你应该能看到类似如下的输出：\r\n\r\n```plaintext\r\nIMAGE               CREATED             CREATED BY                                      SIZE                COMMENT\r\na78a40cbf866        18 seconds ago      /bin/sh -c #(nop)  CMD [\"node\" \"src/index.j…    0B                  \r\nf1d1808565d6        19 seconds ago      /bin/sh -c yarn install --production            85.4MB              \r\na2c054d14948        36 seconds ago      /bin/sh -c #(nop) COPY dir:5dc710ad87c789593…   198kB               \r\n9577ae713121        37 seconds ago      /bin/sh -c #(nop) WORKDIR /app                  0B                  \r\nb95baba1cfdb        13 days ago         /bin/sh -c #(nop)  CMD [\"node\"]                 0B                  \r\n<missing>           13 days ago         /bin/sh -c #(nop)  ENTRYPOINT [\"docker-entry…   0B                  \r\n<missing>           13 days ago         /bin/sh -c #(nop) COPY file:238737301d473041…   116B                \r\n<missing>           13 days ago         /bin/sh -c apk add --no-cache --virtual .bui…   5.35MB              \r\n<missing>           13 days ago         /bin/sh -c #(nop)  ENV YARN_VERSION=1.21.1      0B                  \r\n<missing>           13 days ago         /bin/sh -c addgroup -g 1000 node     && addu…   74.3MB              \r\n<missing>           13 days ago         /bin/sh -c #(nop)  ENV NODE_VERSION=12.14.1     0B                  \r\n<missing>           13 days ago         /bin/sh -c #(nop)  CMD [\"/bin/sh\"]              0B                  \r\n<missing>           13 days ago         /bin/sh -c #(nop) ADD file:e69d441d729412d24…   5.59MB\r\n```\r\n\r\n每一行代表镜像中的一层，默认最新的一层显示在最上方。使用这条命令，还可以快速查看镜像中每一层的大小。\r\n2. 命令默认会对较长的内容进行自动省略处理以保持整洁的输出。如果想查看完整的内容，可以添加 `--no-trunc` 标志。\r\n\r\n```bash\r\ndocker image history --no-trunc todo-app\r\n```\r\n\r\n## 层缓存\r\n\r\n现在我们已经知道了镜像是分层的，再记住一点：`一旦某一层有更新，该层以及它的所有下层也必须重新构建`。利用好这一特性将有助于减少构建镜像所需花费的时间。\r\n\r\n回顾之前创建的 Dockerfile 文件内容\r\n\r\n```dockerfile\r\nFROM node:12-alpine\r\nWORKDIR /app\r\nCOPY . .\r\nRUN yarn install --production\r\nCMD [\"node\", \"src/index.js\"]\r\n```\r\n\r\n对照上一步执行 `docker image history` 的输出结果，会发现 Dockerfile 文中的每一行命令都对应到镜像中的一个层。你应该还记得，在之前的章节当我们只对源码做一小点文本的修改，但是在更新镜像时，同样必须重新执行每个层的命令，比如重新之下 yarn install 安装依赖等等。显然每次都执行 yarn 命令安装依赖是多余的，有没有解决方法？\r\n\r\n要解决这个问题，需要对 Dockerfile 文件进行修改，调整几条命令的执行顺序就可以利用镜像的缓存功能避免执行多余的 yarn install 操作了。对于基于 Node 的应用程序，这些依赖项是在 package.json 文件中定义的。因此，我们只需先把该文件复杂到容器，再安装依赖，然后复制剩下的内容。这样调整之后，只有当 `package.json` 文件有变动时才会执行 yarn install 操作。\r\n\r\n1. 如上所述调整我们的 Dockerfile 文件：增加一行 `COPY package.json yarn.lock ./`；同时将 `COPY . .` 移到 `RUN yarn install --production` 之后\r\n   \r\n   ```dockerfile hl_lines=\"3 4 5\"\r\n   FROM node:12-alpine\r\n   WORKDIR /app\r\n   COPY package.json yarn.lock ./\r\n   RUN yarn install --production\r\n   COPY . .\r\n   CMD [\"node\", \"src/index.js\"]\r\n   ```\r\n2. 在与 Dockerfile 相同的目录下新创建一个名为 `.dockerignore` 的文件，内容如下:\r\n   \r\n   ```ignore\r\n   node_modules\r\n   ```\r\n   \r\n   `.dockerignore` 文件可以告诉 Docker 在构建镜像时忽略某些文件或文件夹，由于 `node_modules` 文件夹是在执行 yarn install 命令时自动生成的，因此它不需要作为镜像的固有内容，忽略它才是对的，而且还可以减少镜像的大小。点击 [这里](https://docs.docker.com/engine/reference/builder/#dockerignore-file) 查看更多关于 `.dockerignore` 的信息。\r\n3. 再次使用 `docker build -t todo-app .` 命令构建新镜像\r\n   \r\n   会看到类似如下输出：\r\n   \r\n   ```plaintext\r\n   Sending build context to Docker daemon  219.1kB\r\n   Step 1/6 : FROM node:12-alpine\r\n   ---> b0dc3a5e5e9e\r\n   Step 2/6 : WORKDIR /app\r\n   ---> Using cache\r\n   ---> 9577ae713121\r\n   Step 3/6 : COPY package.json yarn.lock ./\r\n   ---> bd5306f49fc8\r\n   Step 4/6 : RUN yarn install --production\r\n   ---> Running in d53a06c9e4c2\r\n   yarn install v1.17.3\r\n   [1/4] Resolving packages...\r\n   [2/4] Fetching packages...\r\n   info fsevents@1.2.9: The platform \"linux\" is incompatible with this module.\r\n   info \"fsevents@1.2.9\" is an optional dependency and failed compatibility check. Excluding it from installation.\r\n   [3/4] Linking dependencies...\r\n   [4/4] Building fresh packages...\r\n   Done in 10.89s.\r\n   Removing intermediate container d53a06c9e4c2\r\n   ---> 4e68fbc2d704\r\n   Step 5/6 : COPY . .\r\n   ---> a239a11f68d8\r\n   Step 6/6 : CMD [\"node\", \"src/index.js\"]\r\n   ---> Running in 49999f68df8f\r\n   Removing intermediate container 49999f68df8f\r\n   ---> e709c03bc597\r\n   Successfully built e709c03bc597\r\n   Successfully tagged todo-app:latest\r\n   ```\r\n   \r\n   这一次你会看到所有层都已重建，因为我们更改了 Dockerfile 文件。\r\n4. 现在我们要再一次修改源码，将 `src/static/index.html` 文件第 11 行 `<title>` 标签的内容改为 \"The Awesome Todo App\"\r\n5. 再次使用 `docker build -t todo-app .` 命令构建镜像。这次的输出应该看起来有些不同了：\r\n   \r\n   ```plaintext hl_lines=\"5 8 11\"\r\n   Sending build context to Docker daemon  219.1kB\r\n   Step 1/6 : FROM node:12-alpine\r\n   ---> b0dc3a5e5e9e\r\n   Step 2/6 : WORKDIR /app\r\n   ---> Using cache\r\n   ---> 9577ae713121\r\n   Step 3/6 : COPY package.json yarn.lock ./\r\n   ---> Using cache\r\n   ---> bd5306f49fc8\r\n   Step 4/6 : RUN yarn install --production\r\n   ---> Using cache\r\n   ---> 4e68fbc2d704\r\n   Step 5/6 : COPY . .\r\n   ---> cccde25a3d9a\r\n   Step 6/6 : CMD [\"node\", \"src/index.js\"]\r\n   ---> Running in 2be75662c150\r\n   Removing intermediate container 2be75662c150\r\n   ---> 458e5c6f080c\r\n   Successfully built 458e5c6f080c\r\n   Successfully tagged todo-app:latest\r\n   ```\r\n   \r\n   这次应该能明显的感觉到构建速度快了很多！因为有好几个层使用了缓存。\r\n\r\n## 多阶段构建\r\n\r\n虽然在本教程中不会做太多的介绍，但是多阶段构建非常有用。\r\n\r\n### Maven/Tomcat 示例\r\n\r\n在构建基于 Java 的应用程序时，需要使用 JDK 将 Java 源代码编译为 Java 字节码。然而， 在生产环境中不需要完整的 JDK，只需 JRE 即可。另外，你可能正在使用 Maven 或 Gradle 之类的工具来帮助构建应用程序，在最终的镜像中也不需要这类开发阶段使用到的工具。使用多阶段构建可以解决这些问题。\r\n\r\n```dockerfile\r\nFROM maven AS build\r\nWORKDIR /app\r\nCOPY . .\r\nRUN mvn package\r\n\r\nFROM Tomcat\r\nCOPY --from=build /app/target/file.war /usr/local/tomcat/webapps\r\n```\r\n\r\n在此示例中，我们使用一个称为 `build` 的阶段，通过 Maven 构建 Java 应用程序。第二个阶段从 `FROM tomcat` 开始，我们从 `build` 这个第一阶段的结果中复制文件。默认情况下最终的镜像内容由最后一个阶段创建（可以使用 `--target` 标志自己指定）。\r\n\r\n### React 示例\r\n\r\n在构建 React 应用程序时，我们需要一个 Node 环境来编译 JS 代码、SASS 样式、以及更多的静态 HTML、JS 和 CSS。如果我们不需要服务器端渲染，则在生产环境中我们甚至都不需要 Node 环境，只需将编译好之后的静态资源放到镜像中即可，如下所示：\r\n\r\n```dockerfile\r\nFROM node:12 AS build\r\nWORKDIR /app\r\nCOPY package* yarn.lock ./\r\nRUN yarn install\r\nCOPY public ./public\r\nCOPY src ./src\r\nRUN yarn run build\r\n\r\nFROM nginx:alpine\r\nCOPY --from=build /app/build /usr/share/nginx/html\r\n```\r\n\r\n## 回顾\r\n\r\n在本节中，先通过对我们的镜像进行安全扫描，以确保我们正在运行和分享的镜像是安全的。然后了解了一些镜像的结构及特点，对我们应用程序的 Dockerfile 文件稍作修改，以便更快地构建镜像。最后通过多阶段构建，将开发环境和生产环境需要的依赖区分开，不止可以减少镜像的大小，还能提高容器的安全性。\r\n\r\n> 原始资料：[Image building tips](https://docs.docker.com/get-started/09_image_best/)\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,3,1,now(),NULL,NULL),
	(11,'Docker 基础知识回顾',NULL,'docker-intro-recap__doc','经过前面几个章节的学习，相信对 Docker 已经不再陌生了：\r\n\r\n- 学习了 Docker 的基本操作\r\n  * 通过 Docker 提供的命令行工具操作 Docker\r\n  * 通过 Docker Desktop 可视化界面操作 Docker\r\n- 学习了如何使用别人的镜像来启动容器\r\n- 学习了如何构建并分享自己的镜像\r\n  * 使用 Volume 保存数据 (**named volume** 和 **bind mounts**)\r\n  * 借助 Network 与其他容器沟通\r\n- 还学习了不少进阶知识\r\n  * 多容器应用 Multi-Container Apps\r\n  * 使用 Docker Compose\r\n  * 构建镜像的最佳实践 （安全扫描、镜像分层、层缓存、多阶段构建 ......)\r\n\r\nDocker 还有很多更高级的功能，它本身也还在不断发展中。在后续的学习过程中，可以留意 [Docker 官网](https://www.docker.com/) 第一时间了解 Docker 最新动态。\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,4,1,now(),NULL,NULL),
	(12,'About the Java Technology',NULL,NULL,'# About the Java Technology\r\n\r\nJava technology is both a programming language and a platform.\r\n\r\n## The Java Programming Language\r\n\r\nThe Java programming language is a high-level language that can be characterized by all of the following buzzwords:\r\n\r\n| | |\r\n| --- | --- |\r\n| Simple | Architecture neutral |\r\n| Object oriented | Portable |\r\n| Distributed | High performance |\r\n| Multithreaded | Robust |\r\n| Dynamic | Secure |\r\n\r\nEach of the preceding buzzwords is explained in [*The Java Language Environment*](http://www.oracle.com/technetwork/java/langenv-140151.html) , a white paper written by James Gosling and Henry McGilton.\r\n\r\nIn the Java programming language, all source code is first written in plain text files ending with the `.java` extension. Those source files are then compiled into `.class` files by the `javac` compiler. A `.class` file does not contain code that is native to your processor; it instead contains *bytecodes* — the machine language of the Java Virtual Machine^[1](https://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html#FOOT)^ (Java VM). The `java` launcher tool then runs your application with an instance of the Java Virtual Machine.\r\n\r\n![Figure showing MyProgram.java, compiler, MyProgram.class, Java VM, and My Program running on a computer.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/fe8fb444-5ad3-4310-8294-a70de7feec66.gif)\r\n\r\nAn overview of the software development process.\r\n\r\nBecause the Java VM is available on many different operating systems, the same `.class` files are capable of running on Microsoft Windows, the Solaris™ Operating System (Solaris OS), Linux, or Mac OS. Some virtual machines, such as the [Java SE HotSpot at a Glance](http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136373.html), perform additional steps at runtime to give your application a performance boost. This includes various tasks such as finding performance bottlenecks and recompiling (to native code) frequently used sections of code.\r\n\r\n![Figure showing source code, compiler, and Java VM\'s for Win32, Solaris OS/Linux, and Mac OS](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/d25cfaae-dd0b-4c8b-bc30-afc8a3761bb9.gif)\r\n\r\nThrough the Java VM, the same application is capable of running on multiple platforms.\r\n\r\n===---block---===\r\n\r\n## The Java Platform\r\n\r\nA *platform* is the hardware or software environment in which a program runs. We\'ve already mentioned some of the most popular platforms like Microsoft Windows, Linux, Solaris OS, and Mac OS. Most platforms can be described as a combination of the operating system and underlying hardware. The Java platform differs from most other platforms in that it\'s a software-only platform that runs on top of other hardware-based platforms.\r\n\r\nThe Java platform has two components:\r\n\r\n* The *Java Virtual Machine*\r\n* The *Java Application Programming Interface* (API)\r\n\r\nYou\'ve already been introduced to the Java Virtual Machine; it\'s the base for the Java platform and is ported onto various hardware-based platforms.\r\n\r\nThe API is a large collection of ready-made software components that provide many useful capabilities. It is grouped into libraries of related classes and interfaces; these libraries are known as *packages*. The next section, [What Can Java Technology Do?](https://docs.oracle.com/javase/tutorial/getStarted/intro/cando.html) highlights some of the functionality provided by the API.\r\n\r\n![Figure showing MyProgram.java, API, Java Virtual Machine, and Hardware-Based Platform](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/c7a60cd7-6c23-4da5-9f87-9edf1bbd1dda.gif)\r\n\r\nThe API and Java Virtual Machine insulate the program from the underlying hardware.\r\n\r\nAs a platform-independent environment, the Java platform can be a bit slower than native code. However, advances in compiler and virtual machine technologies are bringing performance close to that of native code without threatening portability.\r\n\r\n[The terms&#34;Java Virtual Machine&#34; and &#34;JVM&#34; mean a Virtual Machine for the Java platform.]()\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,5,2,now(),NULL,NULL),
	(13,'What Can Java Technology Do?',NULL,NULL,'\r\n',NULL,NULL,0,'The general-purpose, high-level Java programming language is a powerful software platform.',NULL,0,0,0,0,NULL,5,2,now(),NULL,NULL),
	(14,'How Will Java Technology Change My Life?',NULL,NULL,'\r\n',NULL,NULL,0,'We can\'t promise you fame, fortune, or even a job if you learn the Java programming language.',NULL,0,0,0,0,NULL,5,2,now(),NULL,NULL),
	(15,'\"Hello World!\" for the NetBeans IDE',NULL,NULL,'## A Checklist  ![a checkmark](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/af23fc51-6b49-4d37-b96d-131ea624e653.gif)\r\n\r\nTo write your first program, you\'ll need:\r\n\r\n1. The Java SE Development Kit (JDK 7 has been selected in this example)\r\n   * For Microsoft Windows, Solaris OS, and Linux: [Java SE Downloads Index](http://www.oracle.com/technetwork/java/javase/downloads/index.html) page\r\n   * For Mac OS X: [developer.apple.com](https://developer.apple.com/)\r\n2. The NetBeans IDE\r\n   * For all platforms: [NetBeans IDE Downloads Index ](http://netbeans.org/downloads/index.html)page\r\n\r\n---\r\n\r\n## Creating Your First Application\r\n\r\nYour first application, `HelloWorldApp`, will simply display the greeting \"Hello World!\" To create this program, you will:\r\n\r\n* Create an IDE project\r\n  When you create an IDE project, you create an environment in which to build and run your applications. Using IDE projects eliminates configuration issues normally associated with developing on the command line. You can build or run your application by choosing a single menu item within the IDE.\r\n* Add code to the generated source file\r\n  A source file contains code, written in the Java programming language, that you and other programmers can understand. As part of creating an IDE project, a skeleton source file will be automatically generated. You will then modify the source file to add the \"Hello World!\" message.\r\n* Compile the source file into a .class file\r\n  The IDE invokes the Java programming language *compiler* `(javac)`, which takes your source file and translates its text into instructions that the Java virtual machine can understand. The instructions contained within this file are known as *bytecodes*.\r\n* Run the program\r\n  The IDE invokes the Java application *launcher tool* (`java`), which uses the Java virtual machine to run your application.\r\n\r\n### Create an IDE Project\r\n\r\nTo create an IDE project:\r\n\r\n1. Launch the NetBeans IDE.\r\n   \r\n   * On Microsoft Windows systems, you can use the NetBeans IDE item in the Start menu.\r\n   * On Solaris OS and Linux systems, you execute the IDE launcher script by navigating to the IDE\'s `bin` directory and typing `./netbeans.`\r\n   * On Mac OS X systems, click the NetBeans IDE application icon.\r\n2. In the NetBeans IDE, choose **File** | **New Project...**.\r\n   ![NetBeans IDE with the File | New Project menu item selected.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/4179617e-d01a-4e7c-b97d-06882d6a013d.png)\r\n   \r\n   NetBeans IDE with the File | New Project menu item selected.\r\n3. In the **New Project** wizard, expand the **Java** category and select **Java Application** as shown in the following figure:\r\n   ![NetBeans IDE, New Project wizard, Choose Project page.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/f02b021e-7675-4ceb-af2e-8c93db6ebd7f.png)\r\n   \r\n   NetBeans IDE, New Project wizard, Choose Project page.\r\n4. In the **Name and Location** page of the wizard, do the following (as shown in the figure below):\r\n   \r\n   * In the **Project Name** field, type `Hello World App`.\r\n   * In the **Create Main Class** field, type `helloworldapp.HelloWorldApp`.\r\n   \r\n   ![NetBeans IDE, New Project wizard, Name and Location page.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/11fdd9d3-35d2-4ce0-bd94-b8a3b2b52805.png)\r\n   \r\n   NetBeans IDE, New Project wizard, Name and Location page.\r\n5. Click Finish.\r\n\r\nThe project is created and opened in the IDE. You should see the following components:\r\n\r\n* The **Projects** window, which contains a tree view of the components of the project, including source files, libraries that your code depends on, and so on.\r\n* The **Source Editor** window with a file called `HelloWorldApp.java` open.\r\n* The **Navigator** window, which you can use to quickly navigate between elements within the selected class.\r\n  ![NetBeans IDE with the HelloWorldApp project open.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/89e2656d-b626-4154-b635-1c44d6d96111.png)\r\n  \r\n  NetBeans IDE with the HelloWorldApp project open.\r\n\r\n---\r\n\r\n===---block---===\r\n\r\n### Add JDK 8 to the Platform List (if necessary)\r\n\r\nIt may be necessary to add JDK 8 to the IDE\'s list of available platforms. To do this, choose Tools | Java Platforms as shown in the following figure:\r\n\r\n![Selecting the Java Platform Manager from the Tools Menu](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/fbcc213c-5f14-4e83-a7d6-25a1033a3cb8.png)\r\n\r\nSelecting the Java Platform Manager from the Tools Menu\r\n\r\nIf you don\'t see JDK 8 (which might appear as 1.8 or 1.8.0) in the list of installed platforms, click **Add Platform**, navigate to your JDK 8 install directory, and click **Finish**. You should now see this newly added platform:\r\n\r\n![The Java Platform Manager from the Tools Menu](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/cd4547d9-ecac-4702-9df2-cfdd60ee6c66.png)\r\n\r\nThe Java Platform Manager\r\n\r\nTo set this JDK as the default for all projects, you can run the IDE with the `--jdkhome` switch on the command line, or by entering the path to the JDK in the `netbeans_j2sdkhome` property of your `INSTALLATION_DIRECTORY/etc/netbeans.conf` file.\r\n\r\nTo specify this JDK for the current project only, select **Hello World App** in the **Projects** pane, choose **File** | **Project Properties (Hello World App)**, click **Libraries**, then select **JDK 1.8** in the **Java Platform** pulldown menu. You should see a screen similar to the following:\r\n\r\n![](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/5719d451-aad6-4419-be54-d936e96a207e.png)\r\n\r\nThe IDE is now configured for JDK 8.\r\n\r\n---\r\n\r\n### Add Code to the Generated Source File\r\n\r\nWhen you created this project, you left the **Create Main Class** checkcbox selected in the **New Project** wizard. The IDE has therefore created a skeleton class for you. You can add the \"Hello World!\" message to the skeleton code by replacing the line:\r\n\r\n```\r\n// TODO code application logic here\r\n```\r\n\r\nwith the line:\r\n\r\n```\r\nSystem.out.println(\"Hello World!\"); // Display the string.\r\n```\r\n\r\nOptionally, you can replace these four lines of generated code:\r\n\r\n```\r\n/**\r\n *\r\n * @author\r\n */\r\n```\r\n\r\nwith these lines:\r\n\r\n```\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply prints \"Hello World!\" to standard output.\r\n */\r\n```\r\n\r\nThese four lines are a code comment and do not affect how the program runs. Later sections of this tutorial explain the use and format of code comments.\r\n\r\n**Be Careful When You Type** ![uppercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/2bcfe1d2-22a6-474f-beaa-b132017b18a9.gif)   ![lowercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/7ac8bc4a-3ae0-4d4f-99ca-bedc1ae5c89c.gif)\r\n\r\n---\r\n\r\n**Note:** Type all code, commands, and file names exactly as shown. Both the compiler (`javac`) and launcher (`java`) are *case-sensitive*, so you must capitalize consistently.\r\n\r\n`HelloWorldApp` is *not* the same as `helloworldapp`.---\r\n\r\nSave your changes by choosing **File** | **Save**.\r\n\r\nThe file should look something like the following:\r\n\r\n```\r\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\n\r\npackage helloworldapp;\r\n\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply prints \"Hello World!\" to standard output.\r\n */\r\npublic class HelloWorldApp {\r\n\r\n   \r\n    /**\r\n     * @param args the command line arguments\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); // Display the string.\r\n    }\r\n\r\n}\r\n```\r\n\r\n===---block---===\r\n\r\n### Compile the Source File into a .class File\r\n\r\nTo compile your source file, choose **Run** | **Build Project (Hello World App)** from the IDE\'s main menu.\r\n\r\nThe Output window opens and displays output similar to what you see in the following figure:\r\n\r\n![Output window showing results of building the HelloWorld project.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/1519e5aa-fa94-4c15-9693-230d1bcb0e9a.png)\r\n\r\nOutput window showing results of building the HelloWorld project.\r\n\r\nIf the build output concludes with the statement `BUILD SUCCESSFUL`, congratulations! You have successfully compiled your program!\r\n\r\nIf the build output concludes with the statement `BUILD FAILED`, you probably have a syntax error in your code. Errors are reported in the Output window as hyperlinked text. You double-click such a hyperlink to navigate to the source of an error. You can then fix the error and once again choose **Run** | **Build Project**.\r\n\r\nWhen you build the project, the bytecode file `HelloWorldApp.class` is generated. You can see where the new file is generated by opening the **Files** window and expanding the **Hello World App/build/classes/helloworldapp** node as shown in the following figure.\r\n\r\n![Files window, showing the generated .class file.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/51758481-5b15-423d-838b-a71432a6b882.png)\r\n\r\nFiles window, showing the generated .class file.\r\n\r\nNow that you have built the project, you can run your program.\r\n\r\n### Run the Program\r\n\r\nFrom the IDE\'s menu bar, choose **Run** | **Run Main Project**.\r\n\r\nThe next figure shows what you should now see.\r\n\r\n![The program prints Hello World! to the Output window (along with other output from the build script).](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/b8f74248-3f80-432e-b77b-a00b10c1a0aa.png)\r\n\r\nThe program prints \"Hello World!\" to the Output window (along with other output from the build script).\r\n\r\nCongratulations! Your program works!\r\n\r\n## Continuing the Tutorial with the NetBeans IDE\r\n\r\nThe next few pages of the tutorial will explain the code in this simple application. After that, the lessons go deeper into core language features and provide many more examples. Although the rest of the tutorial does not give specific instructions about using the NetBeans IDE, you can easily use the IDE to write and run the sample code. The following are some tips on using the IDE and explanations of some IDE behavior that you are likely to see:\r\n\r\n* Once you have created a project in the IDE, you can add files to the project using the **New File** wizard. Choose **File** | **New File**, and then select a template in the wizard, such as the Empty Java File template.\r\n* You can compile and run an individual file (as opposed to a whole project) using the IDE\'s **Compile File** (F9) and **Run File** (Shift-F6) commands. If you use the **Run Main Project** command, the IDE will run the file that the IDE associates as the main class of the main project. Therefore, if you create an additional class in your HelloWorldApp project and then try to run that file with the **Run Main Project** command, the IDE will run the `HelloWorldApp` file instead.\r\n* You might want to create separate IDE projects for sample applications that include more than one source file.\r\n* As you are typing in the IDE, a code completion box might periodically appear. You can either ignore the code completion box and keep typing, or you can select one of the suggested expressions. If you would prefer not to have the code completion box automatically appear, you can turn off the feature. Choose **Tools** | **Options** | **Editor**, click the **Code Completion** tab and clear the **Auto Popup Completion Window** check box.\r\n* If you want to rename the node for a source file in the **Projects** window, choose **Refactor** from IDE\'s main menu. The IDE prompts you with the **Rename** dialog box to lead you through the options of renaming the class and the updating of code that refers to that class. Make the changes and click **Refactor** to apply the changes. This sequence of clicks might seem unnecessary if you have just a single class in your project, but it is very useful when your changes affect other parts of your code in larger projects.\r\n* For a more thorough guide to the features of the NetBeans IDE, see the [NetBeans Documentation](https://netbeans.org/kb/) page.\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,6,2,now(),NULL,NULL),
	(16,'\"Hello World!\" for Microsoft Windows',NULL,NULL,'## A Checklist  ![a checkmark](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/45542144-f207-4875-beca-b70b098d1a4f.gif)\r\n\r\nTo write your first program, you\'ll need:\r\n\r\n1. The Java SE Development Kit 8 (JDK 8)\r\n   You can [download the Windows version now](http://www.oracle.com/technetwork/java/javase/downloads/index.html). (Make sure you download the **JDK**, *not* the JRE.) Consult the [installation instructions](https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html).\r\n2. A text editor\r\n   In this example, we\'ll use Notepad, a simple editor included with the Windows platforms. You can easily adapt these instructions if you use a different text editor.\r\n\r\nThese two items are all you\'ll need to write your first application.\r\n\r\n---\r\n\r\n## Creating Your First Application\r\n\r\nYour first application, `HelloWorldApp`, will simply display the greeting \"Hello world!\". To create this program, you will:\r\n\r\n* Create a source file\r\n  A source file contains code, written in the Java programming language, that you and other programmers can understand. You can use any text editor to create and edit source files.\r\n* Compile the source file into a .class file\r\n  The Java programming language *compiler* (`javac`) takes your source file and translates its text into instructions that the Java virtual machine can understand. The instructions contained within this file are known as *bytecodes*.\r\n* Run the program\r\n  The Java application *launcher tool* (`java`) uses the Java virtual machine to run your application.\r\n\r\n### Create a Source File\r\n\r\nTo create a source file, you have two options:\r\n\r\n* You can save the file `<a class=\"SourceLink\" target=\"_blank\" href=\"https://docs.oracle.com/javase/tutorial/getStarted/application/examples/HelloWorldApp.java\" onclick=\"showCode(\'../../displayCode.html\', \'../application/examples/HelloWorldApp.java\'); return false;\"><code>HelloWorldApp.java</code></a>` on your computer and avoid a lot of typing. Then, you can go straight to [Compile the Source File into a `.class` File](https://docs.oracle.com/javase/tutorial/getStarted/cupojava/win32.html#win32-2b).\r\n* Or, you can use the following (longer) instructions.\r\n\r\nFirst, start your editor. You can launch the Notepad editor from the **Start** menu by selecting **Programs > Accessories > Notepad**. In a new document, type in the following code:\r\n\r\n```\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply prints \"Hello World!\" to standard output.\r\n */\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); // Display the string.\r\n    }\r\n}\r\n```\r\n\r\n**Be Careful When You Type** ![uppercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/863e40d6-d976-4b63-bfbd-69dc09654eed.gif)   ![lowercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/ae57cfd7-e0ce-4270-87aa-50af36cfaaec.gif)\r\n\r\n---\r\n\r\n**Note:** Type all code, commands, and file names exactly as shown. Both the compiler (`javac`) and launcher (`java`) are *case-sensitive*, so you must capitalize consistently.\r\n\r\n`HelloWorldApp` is *not* the same as `helloworldapp`.---\r\n\r\nSave the code in a file with the name `HelloWorldApp.java`. To do this in Notepad, first choose the **File > Save As ...** menu item. Then, in the **Save As** dialog box:\r\n\r\n1. Using the **Save in** combo box, specify the folder (directory) where you\'ll save your file. In this example, the directory is `myapplication` on the `C` drive.\r\n2. In the **File name** text field, type `\"HelloWorldApp.java\"`, without the quotation marks.\r\n3. From the **Save as type** combo box, choose **Text Documents (*.txt)**.\r\n4. In the **Encoding** combo box, leave the encoding as ANSI.\r\n\r\nWhen you\'re finished, the dialog box should look like this.\r\n\r\n![TEXT The Save As dialog, as described in the text.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/c0b09990-d377-483e-a482-4a9c85072f1b.png)\r\n\r\nThe Save As dialog just before you click **Save**.\r\n\r\nNow click **Save**, and exit Notepad.\r\n\r\n===---block---===\r\n\r\n### Compile the Source File into a .class File\r\n\r\nBring up a shell, or \"command,\" window. You can do this from the **Start** menu by choosing **Run...** and then entering `cmd`. The shell window should look similar to the following figure.\r\n\r\n![a window where you can enter DOS commands](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/d54cdd74-67ba-4809-a230-a69f1763fd22.png)\r\n\r\nA shell window.\r\n\r\nThe prompt shows your *current directory*. When you bring up the prompt, your current directory is usually your home directory for Windows XP (as shown in the preceding figure.\r\n\r\nTo compile your source file, change your current directory to the directory where your file is located. For example, if your source directory is `myapplication` on the `C` drive, type the following command at the prompt and press **Enter**:\r\n\r\n```\r\ncd C:\\myapplication\r\n```\r\n\r\nNow the prompt should change to `C:\\myapplication>`.\r\n\r\n---\r\n\r\n**Note:** To change to a directory on a different drive, you must type an extra command: the name of the drive. For example, to change to the `myapplication` directory on the `D` drive, you must enter `D:`, as follows:\r\n\r\n```\r\nC:\\>D:\r\n\r\nD:\\>cd myapplication\r\n\r\nD:\\myapplication>\r\n```\r\n\r\n---\r\n\r\nIf you enter `dir` at the prompt, you should see your source file, as follows:\r\n\r\n```\r\nC:\\>cd myapplication\r\n\r\nC:\\myapplication>dir\r\n Volume in drive C is System\r\n Volume Serial Number is F2E8-C8CC\r\n\r\n Directory of C:\\myapplication\r\n\r\n2014-04-24  01:34 PM    <DIR>          .\r\n2014-04-24  01:34 PM    <DIR>          ..\r\n2014-04-24  01:34 PM               267 HelloWorldApp.java\r\n               1 File(s)            267 bytes\r\n               2 Dir(s)  93,297,991,680 bytes free\r\n\r\nC:\\myapplication>\r\n```\r\n\r\nNow you are ready to compile. At the prompt, type the following command and press **Enter**.\r\n\r\n```\r\njavac HelloWorldApp.java\r\n```\r\n\r\nThe compiler has generated a bytecode file, `HelloWorldApp.class`. At the prompt, type `dir` to see the new file that was generated as follows:\r\n\r\n```\r\nC:\\myapplication>javac HelloWorldApp.java\r\n\r\nC:\\myapplication>dir\r\n Volume in drive C is System\r\n Volume Serial Number is F2E8-C8CC\r\n\r\n Directory of C:\\myapplication\r\n\r\n2014-04-24  02:07 PM    <DIR>          .\r\n2014-04-24  02:07 PM    <DIR>          ..\r\n2014-04-24  02:07 PM               432 HelloWorldApp.class\r\n2014-04-24  01:34 PM               267 HelloWorldApp.java\r\n               2 File(s)            699 bytes\r\n               2 Dir(s)  93,298,032,640 bytes free\r\n\r\nC:\\myapplication>\r\n```\r\n\r\nNow that you have a `.class` file, you can run your program.\r\n\r\nIf you encounter problems with the instructions in this step, consult the [Common Problems (and Their Solutions)](https://docs.oracle.com/javase/tutorial/getStarted/problems/index.html).\r\n\r\n### Run the Program\r\n\r\nIn the same directory, enter the following command at the prompt:\r\n\r\n```\r\njava -cp . HelloWorldApp\r\n```\r\n\r\nYou should see the following on your screen:\r\n\r\n```\r\nC:\\myapplication>java -cp . HelloWorldApp\r\nHello World!\r\n\r\nC:\\myapplication>\r\n```\r\n\r\nCongratulations! Your program works!\r\n\r\nIf you encounter problems with the instructions in this step, consult the [Common Problems (and Their Solutions)](https://docs.oracle.com/javase/tutorial/getStarted/problems/index.html).\r\n\r\n',NULL,NULL,0,'It\'s time to write your first application! ',NULL,0,0,0,0,NULL,6,2,now(),NULL,NULL),
	(17,'\"Hello World!\" for Solaris OS, Linux, and Mac OS X',NULL,NULL,'## A Checklist  ![a checkmark](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/44ed8331-e253-47e6-bb2a-23b5e7e7e833.gif)\r\n\r\nTo write your first program, you\'ll need:\r\n\r\n1. The Java SE Development Kit 8 (JDK 8)\r\n   You can [download the version for Solaris OS, Linux, or Mac OS X](http://www.oracle.com/technetwork/java/javase/downloads/index.html). (Make sure you download the **JDK**, *not* the JRE.) Consult the [installation instructions](https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html).\r\n2. A text editor\r\n   In this example, we\'ll use Pico, an editor available for many UNIX-based platforms. You can easily adapt these instructions if you use a different text editor, such as `vi` or `emacs`.\r\n\r\nThese two items are all you\'ll need to write your first application.\r\n\r\n---\r\n\r\n## Creating Your First Application\r\n\r\nYour first application, `HelloWorldApp`, will simply display the greeting \"Hello world!\". To create this program, you will:\r\n\r\n* Create a source file\r\n  A source file contains code, written in the Java programming language, that you and other programmers can understand. You can use any text editor to create and edit source files.\r\n* Compile the source file into a .class file\r\n  The Java programming language *compiler* (`javac`) takes your source file and translates its text into instructions that the Java virtual machine can understand. The instructions contained within this `.class` file are known as *bytecodes*.\r\n* Run the program\r\n  The Java application *launcher tool* (`java`) uses the Java virtual machine to run your application.\r\n\r\n### Create a Source File\r\n\r\nTo create a source file, you have two options:\r\n\r\n* You can save the file `<a class=\"SourceLink\" target=\"_blank\" href=\"https://docs.oracle.com/javase/tutorial/getStarted/application/examples/HelloWorldApp.java\" onclick=\"showCode(\'../../displayCode.html\', \'../application/examples/HelloWorldApp.java\'); return false;\"><code>HelloWorldApp.java</code></a>` on your computer and avoid a lot of typing. Then, you can go straight to [Compile the Source File](https://docs.oracle.com/javase/tutorial/getStarted/cupojava/unix.html#unix-2b).\r\n* Or, you can use the following (longer) instructions.\r\n\r\nFirst, open a shell, or \"terminal,\" window.\r\n\r\n![A new terminal window.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/ebea21f4-8a24-4662-887a-4027738eb9e6.gif)\r\n\r\nA new terminal window.\r\n\r\nWhen you first bring up the prompt, your *current directory* will usually be your *home directory*. You can change your current directory to your home directory at any time by typing `cd` at the prompt and then pressing **Return**.\r\n\r\nThe source files you create should be kept in a separate directory. You can create a directory by using the command `mkdir`. For example, to create the directory `examples/java` in the /tmp directory, use the following commands:\r\n\r\n```\r\ncd /tmp\r\nmkdir examples\r\ncd examples\r\nmkdir java\r\n```\r\n\r\nTo change your current directory to this new directory, you then enter:\r\n\r\n```\r\ncd /tmp/examples/java\r\n```\r\n\r\nNow you can start creating your source file.\r\n\r\nStart the Pico editor by typing `pico` at the prompt and pressing **Return**. If the system responds with the message `pico: command not found`, then Pico is most likely unavailable. Consult your system administrator for more information, or use another editor.\r\n\r\nWhen you start Pico, it\'ll display a new, blank *buffer*. This is the area in which you will type your code.\r\n\r\nType the following code into the new buffer:\r\n\r\n```\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply prints \"Hello World!\" to standard output.\r\n */\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); // Display the string.\r\n    }\r\n}\r\n```\r\n\r\n**Be Careful When You Type** ![uppercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/ea1d7dcb-1161-4687-8ee0-c144e9791965.gif)   ![lowercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/db0e95ed-2f7a-4954-9a10-b4940de17a73.gif)\r\n\r\n---\r\n\r\n**Note:** Type all code, commands, and file names exactly as shown. Both the compiler (`javac`) and launcher (`java`) are *case-sensitive*, so you must capitalize consistently.\r\n\r\n`HelloWorldApp` is *not* the same as `helloworldapp`.---\r\n\r\nSave the code in a file with the name `HelloWorldApp.java`. In the Pico editor, you do this by typing **Ctrl-O** and then, at the bottom where you see the prompt `File Name to write:`, entering the directory in which you wish to create the file, followed by `HelloWorldApp.java`. For example, if you wish to save `HelloWorldApp.java` in the directory `/tmp/examples/java`, then you type `/tmp/examples/java/HelloWorldApp.java` and press **Return**.\r\n\r\nYou can type **Ctrl-X** to exit Pico.\r\n\r\n===---block---===\r\n\r\n### Compile the Source File into a `.class` File\r\n\r\nBring up another shell window. To compile your source file, change your current directory to the directory where your file is located. For example, if your source directory is `/tmp/examples/java`, type the following command at the prompt and press **Return**:\r\n\r\n```\r\ncd /tmp/examples/java\r\n```\r\n\r\nIf you enter `pwd` at the prompt, you should see the current directory, which in this example has been changed to `/tmp/examples/java`.\r\n\r\nIf you enter `ls` at the prompt, you should see your file.\r\n\r\n![Results of the ls command, showing the .java source file.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/be4992ef-b843-45a1-8e34-01b1c3d7f393.gif)\r\n\r\nResults of the `ls` command, showing the `.java` source file.\r\n\r\nNow are ready to compile the source file. At the prompt, type the following command and press **Return**.\r\n\r\n```\r\njavac HelloWorldApp.java\r\n```\r\n\r\nThe compiler has generated a bytecode file, `HelloWorldApp.class`. At the prompt, type `ls` to see the new file that was generated: the following figure.\r\n\r\n![Results of the ls command, showing the generated .class file.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/95673bb8-6006-461c-a3c2-b3493b8b9743.gif)\r\n\r\nResults of the `ls` command, showing the generated `.class` file.\r\n\r\nNow that you have a `.class` file, you can run your program.\r\n\r\nIf you encounter problems with the instructions in this step, consult the [Common Problems (and Their Solutions)](https://docs.oracle.com/javase/tutorial/getStarted/problems/index.html).\r\n\r\n### Run the Program\r\n\r\nIn the same directory, enter at the prompt:\r\n\r\n```\r\njava HelloWorldApp\r\n```\r\n\r\nThe next figure shows what you should now see.\r\n\r\n![The output prints Hello World! to the screen.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/8c55906b-0048-4d65-a05c-b93b730cb9fa.gif)\r\n\r\nThe output prints \"Hello World!\" to the screen.\r\n\r\nCongratulations! Your program works!\r\n\r\nIf you encounter problems with the instructions in this step, consult the [Common Problems (and Their Solutions)](https://docs.oracle.com/javase/tutorial/getStarted/problems/index.html).\r\n\r\n',NULL,NULL,0,'It\'s time to write your first application! These detailed instructions are for users of Solaris OS, Linux, and Mac OS X.',NULL,0,0,0,0,NULL,6,2,now(),NULL,NULL),
	(18,'How it works',NULL,NULL,'Now that you\'ve seen the \"Hello World!\" application (and perhaps even compiled and run it), you might be wondering how it works. Here again is its code:\r\n\r\n```\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); // Display the string.\r\n    }\r\n}\r\n```\r\n\r\nThe \"Hello World!\" application consists of three primary components: [source code comments](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html#COMMENTS), [the `HelloWorldApp` class definition](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html#CLASS_DEF), and [the `main` method](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html#MAIN). The following explanation will provide you with a basic understanding of the code, but the deeper implications will only become apparent after you\'ve finished reading the rest of the tutorial.\r\n\r\n## [Source Code Comments]()\r\n\r\n[The following bold text defines the *comments* of the &#34;Hello World!&#34; application:]()\r\n\r\n<pre><b>/**\r\n * The HelloWorldApp class implements an application that\r\n * simply prints &#34;Hello World!&#34; to standard output.\r\n */</b>\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(&#34;Hello World!&#34;); <b>// Display the string.</b>\r\n    }\r\n}\r\n</pre>\r\n\r\nComments are ignored by the compiler but are useful to other programmers. The Java programming language supports three kinds of comments:\r\n\r\n`/*<span> </span><em>text</em><span> </span>*/` The compiler ignores everything from `/*` to `*/`.`/**<span> </span><em>documentation</em><span> </span>*/` This indicates a documentation comment (*doc comment*, for short). The compiler ignores this kind of comment, just like it ignores comments that use `/*` and `*/`. The `javadoc` tool uses doc comments when preparing automatically generated documentation. For more information on `javadoc`, see the [Javadoc™ tool documentation](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html) .`//<span> </span><em>text</em>` The compiler ignores everything from `//` to the end of the line.## [The `HelloWorldApp` Class Definition]()\r\n\r\n[The following bold text begins the class definition block for the &#34;Hello World!&#34; application:]()\r\n\r\n```\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply displays \"Hello World!\" to the standard output.\r\n */\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); // Display the string.\r\n    }\r\n}\r\n```\r\n\r\nAs shown above, the most basic form of a class definition is:\r\n\r\n```\r\nclass name {\r\n    . . .\r\n}\r\n```\r\n\r\nThe keyword `class` begins the class definition for a class named `name`, and the code for each class appears between the opening and closing curly braces marked in bold above. Chapter 2 provides an overview of classes in general, and Chapter 4 discusses classes in detail. For now it is enough to know that every application begins with a class definition.\r\n\r\n===---block---===\r\n\r\n## [The `main` Method]()\r\n\r\n[The following bold text begins the definition of the `main` method:]()\r\n\r\n```\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply displays \"Hello World!\" to the standard output.\r\n */\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); //Display the string.\r\n    }\r\n}\r\n```\r\n\r\nIn the Java programming language, every application must contain a `main` method whose signature is:\r\n\r\n```\r\npublic static void main(String[] args)\r\n```\r\n\r\nThe modifiers `public` and `static` can be written in either order (`public static` or `static public`), but the convention is to use `public static` as shown above. You can name the argument anything you want, but most programmers choose \"args\" or \"argv\".\r\n\r\nThe `main` method is similar to the `main` function in C and C++; it\'s the entry point for your application and will subsequently invoke all the other methods required by your program.\r\n\r\nThe `main` method accepts a single argument: an array of elements of type `String`.\r\n\r\n```\r\npublic static void main(String[] args)\r\n```\r\n\r\nThis array is the mechanism through which the runtime system passes information to your application. For example:\r\n\r\n```\r\nJava MyApp arg1 arg2\r\n```\r\n\r\nEach string in the array is called a *command-line argument*. Command-line arguments let users affect the operation of the application without recompiling it. For example, a sorting program might allow the user to specify that the data be sorted in descending order with this command-line argument:\r\n\r\n```\r\n-descending\r\n```\r\n\r\nThe \"Hello World!\" application ignores its command-line arguments, but you should be aware of the fact that such arguments do exist.\r\n\r\nFinally, the line:\r\n\r\n```\r\nSystem.out.println(\"Hello World!\");\r\n```\r\n\r\nuses the `System` class from the core library to print the \"Hello World!\" message to standard output. Portions of this library (also known as the \"Application Programming Interface\", or \"API\") will be discussed throughout the remainder of the tutorial.\r\n\r\n',NULL,NULL,0,'Now that you\'ve seen the \"Hello World!\" application (and perhaps even compiled and run it), you might be wondering how it works.',NULL,0,0,0,0,NULL,7,2,now(),NULL,NULL),
	(19,'Common Problems (and Their Solutions)',NULL,NULL,'## [Compiler Problems]()\r\n\r\n**Common Error Messages on Microsoft Windows Systems**\r\n\r\n`<strong>\'javac\' is not recognized as an internal or external command, operable program or batch file</strong>`\r\n\r\nIf you receive this error, Windows cannot find the compiler (`javac`).\r\n\r\nHere\'s one way to tell Windows where to find `javac`. Suppose you installed the JDK in `C:\\jdk1.8.0`. At the prompt you would type the following command and press Enter:\r\n\r\n```\r\nC:\\jdk1.8.0\\bin\\javac HelloWorldApp.java\r\n```\r\n\r\nIf you choose this option, you\'ll have to precede your `javac` and `java` commands with `C:\\jdk1.8.0\\bin\\` each time you compile or run a program. To avoid this extra typing, consult the section [Updating the PATH variable](https://docs.oracle.com/javase/8/docs/technotes/guides/install/windows_jdk_install.html#BABGDJFH) in the JDK 8 installation instructions.\r\n\r\n`<strong>Class names, \'HelloWorldApp\', are only accepted if annotation processing is explicitly requested</strong>`\r\n\r\nIf you receive this error, you forgot to include the `.java` suffix when compiling the program. Remember, the command is `javac HelloWorldApp.java` not `javac HelloWorldApp`.\r\n\r\n**Common Error Messages on UNIX Systems**\r\n\r\n`javac: Command not found`\r\n\r\nIf you receive this error, UNIX cannot find the compiler, `javac`.\r\n\r\nHere\'s one way to tell UNIX where to find `javac`. Suppose you installed the JDK in `/usr/local/jdk1.8.0`. At the prompt you would type the following command and press Return:\r\n\r\n```\r\n/usr/local/jdk1.8.0/javac HelloWorldApp.java\r\n```\r\n\r\n**Note:** If you choose this option, each time you compile or run a program, you\'ll have to precede your `javac` and `java` commands with `/usr/local/jdk1.8.0/`. To avoid this extra typing, you could add this information to your PATH variable. The steps for doing so will vary depending on which shell you are currently running.\r\n\r\n`<strong>Class names, \'HelloWorldApp\', are only accepted if annotation processing is explicitly requested</strong>`\r\n\r\nIf you receive this error, you forgot to include the `.java` suffix when compiling the program. Remember, the command is `javac HelloWorldApp.java` not `javac HelloWorldApp`.\r\n\r\n**Syntax Errors (All Platforms)**\r\n\r\nIf you mistype part of a program, the compiler may issue a *syntax* error. The message usually displays the type of the error, the line number where the error was detected, the code on that line, and the position of the error within the code. Here\'s an error caused by omitting a semicolon (`;`) at the end of a statement:\r\n\r\n```\r\nTesting.java:8: error: \';\' expected\r\n            count++\r\n                   ^\r\n1 error\r\n```\r\n\r\nIf you see any compiler errors, then your program did not successfully compile, and the compiler did not create a `.class` file. Carefully verify the program, fix any errors that you detect, and try again.\r\n\r\n**Semantic Errors**\r\n\r\nIn addition to verifying that your program is syntactically correct, the compiler checks for other basic correctness. For example, the compiler warns you each time you use a variable that has not been initialized:\r\n\r\n```\r\nTesting.java:8: error: variable count might not have been initialized\r\n            count++;\r\n            ^\r\nTesting.java:9: error: variable count might not have been initialized\r\n        System.out.println(\"Input has \" + count + \" chars.\");\r\n                                          ^\r\n2 errors\r\n```\r\n\r\nAgain, your program did not successfully compile, and the compiler did not create a `.class` file. Fix the error and try again.\r\n\r\n===---block---===\r\n\r\n## [Runtime Problems]()\r\n\r\nError Messages on Microsoft Windows Systems\r\n\r\n`Exception in thread \"main\" java.lang.NoClassDefFoundError: HelloWorldApp`\r\n\r\nIf you receive this error, `java` cannot find your bytecode file, `HelloWorldApp.class`.\r\n\r\nOne of the places `java` tries to find your `.class` file is your current directory. So if your `.class` file is in `C:\\java`, you should change your current directory to that. To change your directory, type the following command at the prompt and press Enter:\r\n\r\n```\r\ncd c:\\java\r\n```\r\n\r\nThe prompt should change to `C:\\java>`. If you enter `dir` at the prompt, you should see your `.java` and `.class` files. Now enter `java HelloWorldApp` again.\r\n\r\nIf you still have problems, you might have to change your CLASSPATH variable. To see if this is necessary, try clobbering the classpath with the following command.\r\n\r\n```\r\nset CLASSPATH=\r\n```\r\n\r\nNow enter `java HelloWorldApp` again. If the program works now, you\'ll have to change your CLASSPATH variable. To set this variable, consult the [Updating the PATH variable](https://docs.oracle.com/javase/8/docs/technotes/guides/install/windows_jdk_install.html#BABGDJFH) section in the JDK 8 installation instructions. The CLASSPATH variable is set in the same manner.\r\n\r\n`<strong>Could not find or load main class HelloWorldApp.class</strong>`\r\n\r\nA common mistake made by beginner programmers is to try and run the `java` launcher on the `.class` file that was created by the compiler. For example, you\'ll get this error if you try to run your program with `java HelloWorldApp.class` instead of `java HelloWorldApp`. Remember, the argument is the *name of the class* that you want to use, *not* the filename.\r\n\r\n**`Exception in thread \"main\" java.lang.NoSuchMethodError: main`**\r\n\r\nThe Java VM requires that the class you execute with it have a `main` method at which to begin execution of your application. [A Closer Look at the &#34;Hello World!&#34; Application](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html) discusses the `main` method in detail.\r\n\r\n**Error Messages on UNIX Systems**\r\n\r\n`Exception in thread \"main\" java.lang.NoClassDefFoundError: HelloWorldApp`\r\n\r\nIf you receive this error, `java` cannot find your bytecode file, `HelloWorldApp.class`.\r\n\r\nOne of the places `java` tries to find your bytecode file is your current directory. So, for example, if your bytecode file is in `/home/jdoe/java`, you should change your current directory to that. To change your directory, type the following command at the prompt and press Return:\r\n\r\n```\r\ncd /home/jdoe/java\r\n```\r\n\r\nIf you enter `pwd` at the prompt, you should see `/home/jdoe/java`. If you enter `ls` at the prompt, you should see your `.java` and `.class` files. Now enter `java HelloWorldApp` again.\r\n\r\nIf you still have problems, you might have to change your CLASSPATH environment variable. To see if this is necessary, try clobbering the classpath with the following command.\r\n\r\n```\r\nunset CLASSPATH\r\n```\r\n\r\nNow enter `java HelloWorldApp` again. If the program works now, you\'ll have to change your CLASSPATH variable in the same manner as the PATH variable above.\r\n\r\n`<strong>Exception in thread \"main\" java.lang.NoClassDefFoundError: HelloWorldApp/class</strong>`\r\n\r\nA common mistake made by beginner programmers is to try and run the `java` launcher on the `.class` file that was created by the compiler. For example, you\'ll get this error if you try to run your program with `java HelloWorldApp.class` instead of `java HelloWorldApp`. Remember, the argument is the *name of the class* that you want to use, *not* the filename.\r\n\r\n**`Exception in thread \"main\" java.lang.NoSuchMethodError: main`**\r\n\r\nThe Java VM requires that the class you execute with it have a `main` method at which to begin execution of your application. [A Closer Look at the &#34;Hello World!&#34; Application](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html) discusses the `main` method in detail.\r\n\r\n**Applet or Java Web Start Application Is Blocked**\r\n\r\nIf you are running an application through a browser and get security warnings that say the application is blocked, check the following items:\r\n\r\n* Verify that the attributes in the JAR file manifest are set correctly for the environment in which the application is running. The Permissions attribute is required. In a NetBeans project, you can open the manifest file from the Files tab of the NetBeans IDE by expanding the project folder and double-clicking manifest.mf.\r\n* Verify that the application is signed by a valid certificate and that the certificate is located in the Signer CA keystore.\r\n* If you are running a local applet, set up a Web server to use for testing. You can also add your application to the exception site list, which is managed in the Security tab of the Java Control Panel.\r\n\r\n',NULL,NULL,0,'',NULL,0,0,0,0,NULL,8,2,now(),NULL,NULL),
	(20,'End of Trail',NULL,NULL,'\r\n',NULL,NULL,0,'You have reached the end of the \"Getting Started\" trail.',NULL,0,0,0,0,NULL,8,2,now(),NULL,NULL);



# --- block data ---
INSERT INTO `block` (`id`, `content`, `content_translation`, `sort_order`, `published`, `lecture_id`, `collection_id`, `created_at`, `updated_at`, `deleted_at`)
VALUES
	(1,'Java technology is both a programming language and a platform.\r\n\r\n## The Java Programming Language\r\n\r\nThe Java programming language is a high-level language that can be characterized by all of the following buzzwords:\r\n\r\n| | |\r\n| --- | --- |\r\n| Simple | Architecture neutral |\r\n| Object oriented | Portable |\r\n| Distributed | High performance |\r\n| Multithreaded | Robust |\r\n| Dynamic | Secure |\r\n\r\nEach of the preceding buzzwords is explained in [*The Java Language Environment*](http://www.oracle.com/technetwork/java/langenv-140151.html) , a white paper written by James Gosling and Henry McGilton.\r\n\r\nIn the Java programming language, all source code is first written in plain text files ending with the `.java` extension. Those source files are then compiled into `.class` files by the `javac` compiler. A `.class` file does not contain code that is native to your processor; it instead contains *bytecodes* — the machine language of the Java Virtual Machine^[1](https://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html#FOOT)^ (Java VM). The `java` launcher tool then runs your application with an instance of the Java Virtual Machine.\r\n\r\n![Figure showing MyProgram.java, compiler, MyProgram.class, Java VM, and My Program running on a computer.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/fe8fb444-5ad3-4310-8294-a70de7feec66.gif)\r\n\r\nAn overview of the software development process.\r\n\r\nBecause the Java VM is available on many different operating systems, the same `.class` files are capable of running on Microsoft Windows, the Solaris™ Operating System (Solaris OS), Linux, or Mac OS. Some virtual machines, such as the [Java SE HotSpot at a Glance](http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136373.html), perform additional steps at runtime to give your application a performance boost. This includes various tasks such as finding performance bottlenecks and recompiling (to native code) frequently used sections of code.\r\n\r\n![Figure showing source code, compiler, and Java VM\'s for Win32, Solaris OS/Linux, and Mac OS](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/d25cfaae-dd0b-4c8b-bc30-afc8a3761bb9.gif)\r\n\r\nThrough the Java VM, the same application is capable of running on multiple platforms.',NULL,0,0,12,2,now(),NULL,NULL),
	(2,'## The Java Platform\r\n\r\nA *platform* is the hardware or software environment in which a program runs. We\'ve already mentioned some of the most popular platforms like Microsoft Windows, Linux, Solaris OS, and Mac OS. Most platforms can be described as a combination of the operating system and underlying hardware. The Java platform differs from most other platforms in that it\'s a software-only platform that runs on top of other hardware-based platforms.\r\n\r\nThe Java platform has two components:\r\n\r\n* The *Java Virtual Machine*\r\n* The *Java Application Programming Interface* (API)\r\n\r\nYou\'ve already been introduced to the Java Virtual Machine; it\'s the base for the Java platform and is ported onto various hardware-based platforms.\r\n\r\nThe API is a large collection of ready-made software components that provide many useful capabilities. It is grouped into libraries of related classes and interfaces; these libraries are known as *packages*. The next section, [What Can Java Technology Do?](https://docs.oracle.com/javase/tutorial/getStarted/intro/cando.html) highlights some of the functionality provided by the API.\r\n\r\n![Figure showing MyProgram.java, API, Java Virtual Machine, and Hardware-Based Platform](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/c7a60cd7-6c23-4da5-9f87-9edf1bbd1dda.gif)\r\n\r\nThe API and Java Virtual Machine insulate the program from the underlying hardware.\r\n\r\nAs a platform-independent environment, the Java platform can be a bit slower than native code. However, advances in compiler and virtual machine technologies are bringing performance close to that of native code without threatening portability.\r\n\r\n[The terms&#34;Java Virtual Machine&#34; and &#34;JVM&#34; mean a Virtual Machine for the Java platform.]()',NULL,0,0,12,2,now(),NULL,NULL),
	(3,'The general-purpose, high-level Java programming language is a powerful software platform. Every full implementation of the Java platform gives you the following features:\r\n\r\n* **Development Tools**: The development tools provide everything you\'ll need for compiling, running, monitoring, debugging, and documenting your applications. As a new developer, the main tools you\'ll be using are the `javac` compiler, the `java` launcher, and the `javadoc` documentation tool.\r\n* **Application Programming Interface (API)**: The API provides the core functionality of the Java programming language. It offers a wide array of useful classes ready for use in your own applications. It spans everything from basic objects, to networking and security, to XML generation and database access, and more. The core API is very large; to get an overview of what it contains, consult the [Java Platform Standard Edition 8 Documentation](https://docs.oracle.com/javase/8/docs/index.html).\r\n* **Deployment Technologies**: The JDK software provides standard mechanisms such as the Java Web Start software and Java Plug-In software for deploying your applications to end users.\r\n* **User Interface Toolkits**: The JavaFX, Swing, and Java 2D toolkits make it possible to create sophisticated Graphical User Interfaces (GUIs).\r\n* **Integration Libraries**: Integration libraries such as the Java IDL API, JDBC API, Java Naming and Directory Interface (JNDI) API, Java RMI, and Java Remote Method Invocation over Internet Inter-ORB Protocol Technology (Java RMI-IIOP Technology) enable database access and manipulation of remote objects.\r\n\r\n',NULL,0,0,13,2,now(),NULL,NULL),
	(4,'We can\'t promise you fame, fortune, or even a job if you learn the Java programming language. Still, it is likely to make your programs better and requires less effort than other languages. We believe that Java technology will help you do the following:\r\n\r\n* **Get started quickly**: Although the Java programming language is a powerful object-oriented language, it\'s easy to learn, especially for programmers already familiar with C or C++.\r\n* **Write less code**: Comparisons of program metrics (class counts, method counts, and so on) suggest that a program written in the Java programming language can be four times smaller than the same program written in C++.\r\n* **Write better code**: The Java programming language encourages good coding practices, and automatic garbage collection helps you avoid memory leaks. Its object orientation, its JavaBeans™ component architecture, and its wide-ranging, easily extendible API let you reuse existing, tested code and introduce fewer bugs.\r\n* **Develop programs more quickly**: The Java programming language is simpler than C++, and as such, your development time could be up to twice as fast when writing in it. Your programs will also require fewer lines of code.\r\n* **Avoid platform dependencies**: You can keep your program portable by avoiding the use of libraries written in other languages.\r\n* **Write once, run anywhere**: Because applications written in the Java programming language are compiled into machine-independent bytecodes, they run consistently on any Java platform.\r\n* **Distribute software more easily**: With Java Web Start software, users will be able to launch your applications with a single click of the mouse. An automatic version check at startup ensures that users are always up to date with the latest version of your software. If an update is available, the Java Web Start software will automatically update their installation.\r\n\r\n',NULL,0,0,14,2,now(),NULL,NULL),
	(5,'## A Checklist  ![a checkmark](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/af23fc51-6b49-4d37-b96d-131ea624e653.gif)\r\n\r\nTo write your first program, you\'ll need:\r\n\r\n1. The Java SE Development Kit (JDK 7 has been selected in this example)\r\n   * For Microsoft Windows, Solaris OS, and Linux: [Java SE Downloads Index](http://www.oracle.com/technetwork/java/javase/downloads/index.html) page\r\n   * For Mac OS X: [developer.apple.com](https://developer.apple.com/)\r\n2. The NetBeans IDE\r\n   * For all platforms: [NetBeans IDE Downloads Index ](http://netbeans.org/downloads/index.html)page\r\n\r\n---\r\n\r\n## Creating Your First Application\r\n\r\nYour first application, `HelloWorldApp`, will simply display the greeting \"Hello World!\" To create this program, you will:\r\n\r\n* Create an IDE project\r\n  When you create an IDE project, you create an environment in which to build and run your applications. Using IDE projects eliminates configuration issues normally associated with developing on the command line. You can build or run your application by choosing a single menu item within the IDE.\r\n* Add code to the generated source file\r\n  A source file contains code, written in the Java programming language, that you and other programmers can understand. As part of creating an IDE project, a skeleton source file will be automatically generated. You will then modify the source file to add the \"Hello World!\" message.\r\n* Compile the source file into a .class file\r\n  The IDE invokes the Java programming language *compiler* `(javac)`, which takes your source file and translates its text into instructions that the Java virtual machine can understand. The instructions contained within this file are known as *bytecodes*.\r\n* Run the program\r\n  The IDE invokes the Java application *launcher tool* (`java`), which uses the Java virtual machine to run your application.\r\n\r\n### Create an IDE Project\r\n\r\nTo create an IDE project:\r\n\r\n1. Launch the NetBeans IDE.\r\n   \r\n   * On Microsoft Windows systems, you can use the NetBeans IDE item in the Start menu.\r\n   * On Solaris OS and Linux systems, you execute the IDE launcher script by navigating to the IDE\'s `bin` directory and typing `./netbeans.`\r\n   * On Mac OS X systems, click the NetBeans IDE application icon.\r\n2. In the NetBeans IDE, choose **File** | **New Project...**.\r\n   ![NetBeans IDE with the File | New Project menu item selected.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/4179617e-d01a-4e7c-b97d-06882d6a013d.png)\r\n   \r\n   NetBeans IDE with the File | New Project menu item selected.\r\n3. In the **New Project** wizard, expand the **Java** category and select **Java Application** as shown in the following figure:\r\n   ![NetBeans IDE, New Project wizard, Choose Project page.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/f02b021e-7675-4ceb-af2e-8c93db6ebd7f.png)\r\n   \r\n   NetBeans IDE, New Project wizard, Choose Project page.\r\n4. In the **Name and Location** page of the wizard, do the following (as shown in the figure below):\r\n   \r\n   * In the **Project Name** field, type `Hello World App`.\r\n   * In the **Create Main Class** field, type `helloworldapp.HelloWorldApp`.\r\n   \r\n   ![NetBeans IDE, New Project wizard, Name and Location page.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/11fdd9d3-35d2-4ce0-bd94-b8a3b2b52805.png)\r\n   \r\n   NetBeans IDE, New Project wizard, Name and Location page.\r\n5. Click Finish.\r\n\r\nThe project is created and opened in the IDE. You should see the following components:\r\n\r\n* The **Projects** window, which contains a tree view of the components of the project, including source files, libraries that your code depends on, and so on.\r\n* The **Source Editor** window with a file called `HelloWorldApp.java` open.\r\n* The **Navigator** window, which you can use to quickly navigate between elements within the selected class.\r\n  ![NetBeans IDE with the HelloWorldApp project open.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/89e2656d-b626-4154-b635-1c44d6d96111.png)\r\n  \r\n  NetBeans IDE with the HelloWorldApp project open.\r\n\r\n---',NULL,0,0,15,2,now(),NULL,NULL),
	(6,'### Add JDK 8 to the Platform List (if necessary)\r\n\r\nIt may be necessary to add JDK 8 to the IDE\'s list of available platforms. To do this, choose Tools | Java Platforms as shown in the following figure:\r\n\r\n![Selecting the Java Platform Manager from the Tools Menu](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/fbcc213c-5f14-4e83-a7d6-25a1033a3cb8.png)\r\n\r\nSelecting the Java Platform Manager from the Tools Menu\r\n\r\nIf you don\'t see JDK 8 (which might appear as 1.8 or 1.8.0) in the list of installed platforms, click **Add Platform**, navigate to your JDK 8 install directory, and click **Finish**. You should now see this newly added platform:\r\n\r\n![The Java Platform Manager from the Tools Menu](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/cd4547d9-ecac-4702-9df2-cfdd60ee6c66.png)\r\n\r\nThe Java Platform Manager\r\n\r\nTo set this JDK as the default for all projects, you can run the IDE with the `--jdkhome` switch on the command line, or by entering the path to the JDK in the `netbeans_j2sdkhome` property of your `INSTALLATION_DIRECTORY/etc/netbeans.conf` file.\r\n\r\nTo specify this JDK for the current project only, select **Hello World App** in the **Projects** pane, choose **File** | **Project Properties (Hello World App)**, click **Libraries**, then select **JDK 1.8** in the **Java Platform** pulldown menu. You should see a screen similar to the following:\r\n\r\n![](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/5719d451-aad6-4419-be54-d936e96a207e.png)\r\n\r\nThe IDE is now configured for JDK 8.\r\n\r\n---\r\n\r\n### Add Code to the Generated Source File\r\n\r\nWhen you created this project, you left the **Create Main Class** checkcbox selected in the **New Project** wizard. The IDE has therefore created a skeleton class for you. You can add the \"Hello World!\" message to the skeleton code by replacing the line:\r\n\r\n```\r\n// TODO code application logic here\r\n```\r\n\r\nwith the line:\r\n\r\n```\r\nSystem.out.println(\"Hello World!\"); // Display the string.\r\n```\r\n\r\nOptionally, you can replace these four lines of generated code:\r\n\r\n```\r\n/**\r\n *\r\n * @author\r\n */\r\n```\r\n\r\nwith these lines:\r\n\r\n```\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply prints \"Hello World!\" to standard output.\r\n */\r\n```\r\n\r\nThese four lines are a code comment and do not affect how the program runs. Later sections of this tutorial explain the use and format of code comments.\r\n\r\n**Be Careful When You Type** ![uppercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/2bcfe1d2-22a6-474f-beaa-b132017b18a9.gif)   ![lowercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/7ac8bc4a-3ae0-4d4f-99ca-bedc1ae5c89c.gif)\r\n\r\n---\r\n\r\n**Note:** Type all code, commands, and file names exactly as shown. Both the compiler (`javac`) and launcher (`java`) are *case-sensitive*, so you must capitalize consistently.\r\n\r\n`HelloWorldApp` is *not* the same as `helloworldapp`.---\r\n\r\nSave your changes by choosing **File** | **Save**.\r\n\r\nThe file should look something like the following:\r\n\r\n```\r\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\n\r\npackage helloworldapp;\r\n\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply prints \"Hello World!\" to standard output.\r\n */\r\npublic class HelloWorldApp {\r\n\r\n   \r\n    /**\r\n     * @param args the command line arguments\r\n     */\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); // Display the string.\r\n    }\r\n\r\n}\r\n```',NULL,0,0,15,2,now(),NULL,NULL),
	(7,'### Compile the Source File into a .class File\r\n\r\nTo compile your source file, choose **Run** | **Build Project (Hello World App)** from the IDE\'s main menu.\r\n\r\nThe Output window opens and displays output similar to what you see in the following figure:\r\n\r\n![Output window showing results of building the HelloWorld project.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/1519e5aa-fa94-4c15-9693-230d1bcb0e9a.png)\r\n\r\nOutput window showing results of building the HelloWorld project.\r\n\r\nIf the build output concludes with the statement `BUILD SUCCESSFUL`, congratulations! You have successfully compiled your program!\r\n\r\nIf the build output concludes with the statement `BUILD FAILED`, you probably have a syntax error in your code. Errors are reported in the Output window as hyperlinked text. You double-click such a hyperlink to navigate to the source of an error. You can then fix the error and once again choose **Run** | **Build Project**.\r\n\r\nWhen you build the project, the bytecode file `HelloWorldApp.class` is generated. You can see where the new file is generated by opening the **Files** window and expanding the **Hello World App/build/classes/helloworldapp** node as shown in the following figure.\r\n\r\n![Files window, showing the generated .class file.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/51758481-5b15-423d-838b-a71432a6b882.png)\r\n\r\nFiles window, showing the generated .class file.\r\n\r\nNow that you have built the project, you can run your program.\r\n\r\n### Run the Program\r\n\r\nFrom the IDE\'s menu bar, choose **Run** | **Run Main Project**.\r\n\r\nThe next figure shows what you should now see.\r\n\r\n![The program prints Hello World! to the Output window (along with other output from the build script).](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/b8f74248-3f80-432e-b77b-a00b10c1a0aa.png)\r\n\r\nThe program prints \"Hello World!\" to the Output window (along with other output from the build script).\r\n\r\nCongratulations! Your program works!\r\n\r\n## Continuing the Tutorial with the NetBeans IDE\r\n\r\nThe next few pages of the tutorial will explain the code in this simple application. After that, the lessons go deeper into core language features and provide many more examples. Although the rest of the tutorial does not give specific instructions about using the NetBeans IDE, you can easily use the IDE to write and run the sample code. The following are some tips on using the IDE and explanations of some IDE behavior that you are likely to see:\r\n\r\n* Once you have created a project in the IDE, you can add files to the project using the **New File** wizard. Choose **File** | **New File**, and then select a template in the wizard, such as the Empty Java File template.\r\n* You can compile and run an individual file (as opposed to a whole project) using the IDE\'s **Compile File** (F9) and **Run File** (Shift-F6) commands. If you use the **Run Main Project** command, the IDE will run the file that the IDE associates as the main class of the main project. Therefore, if you create an additional class in your HelloWorldApp project and then try to run that file with the **Run Main Project** command, the IDE will run the `HelloWorldApp` file instead.\r\n* You might want to create separate IDE projects for sample applications that include more than one source file.\r\n* As you are typing in the IDE, a code completion box might periodically appear. You can either ignore the code completion box and keep typing, or you can select one of the suggested expressions. If you would prefer not to have the code completion box automatically appear, you can turn off the feature. Choose **Tools** | **Options** | **Editor**, click the **Code Completion** tab and clear the **Auto Popup Completion Window** check box.\r\n* If you want to rename the node for a source file in the **Projects** window, choose **Refactor** from IDE\'s main menu. The IDE prompts you with the **Rename** dialog box to lead you through the options of renaming the class and the updating of code that refers to that class. Make the changes and click **Refactor** to apply the changes. This sequence of clicks might seem unnecessary if you have just a single class in your project, but it is very useful when your changes affect other parts of your code in larger projects.\r\n* For a more thorough guide to the features of the NetBeans IDE, see the [NetBeans Documentation](https://netbeans.org/kb/) page.',NULL,0,0,15,2,now(),NULL,NULL),
	(8,'## A Checklist  ![a checkmark](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/45542144-f207-4875-beca-b70b098d1a4f.gif)\r\n\r\nTo write your first program, you\'ll need:\r\n\r\n1. The Java SE Development Kit 8 (JDK 8)\r\n   You can [download the Windows version now](http://www.oracle.com/technetwork/java/javase/downloads/index.html). (Make sure you download the **JDK**, *not* the JRE.) Consult the [installation instructions](https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html).\r\n2. A text editor\r\n   In this example, we\'ll use Notepad, a simple editor included with the Windows platforms. You can easily adapt these instructions if you use a different text editor.\r\n\r\nThese two items are all you\'ll need to write your first application.\r\n\r\n---\r\n\r\n## Creating Your First Application\r\n\r\nYour first application, `HelloWorldApp`, will simply display the greeting \"Hello world!\". To create this program, you will:\r\n\r\n* Create a source file\r\n  A source file contains code, written in the Java programming language, that you and other programmers can understand. You can use any text editor to create and edit source files.\r\n* Compile the source file into a .class file\r\n  The Java programming language *compiler* (`javac`) takes your source file and translates its text into instructions that the Java virtual machine can understand. The instructions contained within this file are known as *bytecodes*.\r\n* Run the program\r\n  The Java application *launcher tool* (`java`) uses the Java virtual machine to run your application.\r\n\r\n### Create a Source File\r\n\r\nTo create a source file, you have two options:\r\n\r\n* You can save the file `<a class=\"SourceLink\" target=\"_blank\" href=\"https://docs.oracle.com/javase/tutorial/getStarted/application/examples/HelloWorldApp.java\" onclick=\"showCode(\'../../displayCode.html\', \'../application/examples/HelloWorldApp.java\'); return false;\"><code>HelloWorldApp.java</code></a>` on your computer and avoid a lot of typing. Then, you can go straight to [Compile the Source File into a `.class` File](https://docs.oracle.com/javase/tutorial/getStarted/cupojava/win32.html#win32-2b).\r\n* Or, you can use the following (longer) instructions.\r\n\r\nFirst, start your editor. You can launch the Notepad editor from the **Start** menu by selecting **Programs > Accessories > Notepad**. In a new document, type in the following code:\r\n\r\n```\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply prints \"Hello World!\" to standard output.\r\n */\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); // Display the string.\r\n    }\r\n}\r\n```\r\n\r\n**Be Careful When You Type** ![uppercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/863e40d6-d976-4b63-bfbd-69dc09654eed.gif)   ![lowercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/ae57cfd7-e0ce-4270-87aa-50af36cfaaec.gif)\r\n\r\n---\r\n\r\n**Note:** Type all code, commands, and file names exactly as shown. Both the compiler (`javac`) and launcher (`java`) are *case-sensitive*, so you must capitalize consistently.\r\n\r\n`HelloWorldApp` is *not* the same as `helloworldapp`.---\r\n\r\nSave the code in a file with the name `HelloWorldApp.java`. To do this in Notepad, first choose the **File > Save As ...** menu item. Then, in the **Save As** dialog box:\r\n\r\n1. Using the **Save in** combo box, specify the folder (directory) where you\'ll save your file. In this example, the directory is `myapplication` on the `C` drive.\r\n2. In the **File name** text field, type `\"HelloWorldApp.java\"`, without the quotation marks.\r\n3. From the **Save as type** combo box, choose **Text Documents (*.txt)**.\r\n4. In the **Encoding** combo box, leave the encoding as ANSI.\r\n\r\nWhen you\'re finished, the dialog box should look like this.\r\n\r\n![TEXT The Save As dialog, as described in the text.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/c0b09990-d377-483e-a482-4a9c85072f1b.png)\r\n\r\nThe Save As dialog just before you click **Save**.\r\n\r\nNow click **Save**, and exit Notepad.',NULL,0,0,16,2,now(),NULL,NULL),
	(9,'### Compile the Source File into a .class File\r\n\r\nBring up a shell, or \"command,\" window. You can do this from the **Start** menu by choosing **Run...** and then entering `cmd`. The shell window should look similar to the following figure.\r\n\r\n![a window where you can enter DOS commands](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/d54cdd74-67ba-4809-a230-a69f1763fd22.png)\r\n\r\nA shell window.\r\n\r\nThe prompt shows your *current directory*. When you bring up the prompt, your current directory is usually your home directory for Windows XP (as shown in the preceding figure.\r\n\r\nTo compile your source file, change your current directory to the directory where your file is located. For example, if your source directory is `myapplication` on the `C` drive, type the following command at the prompt and press **Enter**:\r\n\r\n```\r\ncd C:\\myapplication\r\n```\r\n\r\nNow the prompt should change to `C:\\myapplication>`.\r\n\r\n---\r\n\r\n**Note:** To change to a directory on a different drive, you must type an extra command: the name of the drive. For example, to change to the `myapplication` directory on the `D` drive, you must enter `D:`, as follows:\r\n\r\n```\r\nC:\\>D:\r\n\r\nD:\\>cd myapplication\r\n\r\nD:\\myapplication>\r\n```\r\n\r\n---\r\n\r\nIf you enter `dir` at the prompt, you should see your source file, as follows:\r\n\r\n```\r\nC:\\>cd myapplication\r\n\r\nC:\\myapplication>dir\r\n Volume in drive C is System\r\n Volume Serial Number is F2E8-C8CC\r\n\r\n Directory of C:\\myapplication\r\n\r\n2014-04-24  01:34 PM    <DIR>          .\r\n2014-04-24  01:34 PM    <DIR>          ..\r\n2014-04-24  01:34 PM               267 HelloWorldApp.java\r\n               1 File(s)            267 bytes\r\n               2 Dir(s)  93,297,991,680 bytes free\r\n\r\nC:\\myapplication>\r\n```\r\n\r\nNow you are ready to compile. At the prompt, type the following command and press **Enter**.\r\n\r\n```\r\njavac HelloWorldApp.java\r\n```\r\n\r\nThe compiler has generated a bytecode file, `HelloWorldApp.class`. At the prompt, type `dir` to see the new file that was generated as follows:\r\n\r\n```\r\nC:\\myapplication>javac HelloWorldApp.java\r\n\r\nC:\\myapplication>dir\r\n Volume in drive C is System\r\n Volume Serial Number is F2E8-C8CC\r\n\r\n Directory of C:\\myapplication\r\n\r\n2014-04-24  02:07 PM    <DIR>          .\r\n2014-04-24  02:07 PM    <DIR>          ..\r\n2014-04-24  02:07 PM               432 HelloWorldApp.class\r\n2014-04-24  01:34 PM               267 HelloWorldApp.java\r\n               2 File(s)            699 bytes\r\n               2 Dir(s)  93,298,032,640 bytes free\r\n\r\nC:\\myapplication>\r\n```\r\n\r\nNow that you have a `.class` file, you can run your program.\r\n\r\nIf you encounter problems with the instructions in this step, consult the [Common Problems (and Their Solutions)](https://docs.oracle.com/javase/tutorial/getStarted/problems/index.html).\r\n\r\n### Run the Program\r\n\r\nIn the same directory, enter the following command at the prompt:\r\n\r\n```\r\njava -cp . HelloWorldApp\r\n```\r\n\r\nYou should see the following on your screen:\r\n\r\n```\r\nC:\\myapplication>java -cp . HelloWorldApp\r\nHello World!\r\n\r\nC:\\myapplication>\r\n```\r\n\r\nCongratulations! Your program works!\r\n\r\nIf you encounter problems with the instructions in this step, consult the [Common Problems (and Their Solutions)](https://docs.oracle.com/javase/tutorial/getStarted/problems/index.html).',NULL,0,0,16,2,now(),NULL,NULL),
	(10,'## A Checklist  ![a checkmark](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/44ed8331-e253-47e6-bb2a-23b5e7e7e833.gif)\r\n\r\nTo write your first program, you\'ll need:\r\n\r\n1. The Java SE Development Kit 8 (JDK 8)\r\n   You can [download the version for Solaris OS, Linux, or Mac OS X](http://www.oracle.com/technetwork/java/javase/downloads/index.html). (Make sure you download the **JDK**, *not* the JRE.) Consult the [installation instructions](https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html).\r\n2. A text editor\r\n   In this example, we\'ll use Pico, an editor available for many UNIX-based platforms. You can easily adapt these instructions if you use a different text editor, such as `vi` or `emacs`.\r\n\r\nThese two items are all you\'ll need to write your first application.\r\n\r\n---\r\n\r\n## Creating Your First Application\r\n\r\nYour first application, `HelloWorldApp`, will simply display the greeting \"Hello world!\". To create this program, you will:\r\n\r\n* Create a source file\r\n  A source file contains code, written in the Java programming language, that you and other programmers can understand. You can use any text editor to create and edit source files.\r\n* Compile the source file into a .class file\r\n  The Java programming language *compiler* (`javac`) takes your source file and translates its text into instructions that the Java virtual machine can understand. The instructions contained within this `.class` file are known as *bytecodes*.\r\n* Run the program\r\n  The Java application *launcher tool* (`java`) uses the Java virtual machine to run your application.\r\n\r\n### Create a Source File\r\n\r\nTo create a source file, you have two options:\r\n\r\n* You can save the file `<a class=\"SourceLink\" target=\"_blank\" href=\"https://docs.oracle.com/javase/tutorial/getStarted/application/examples/HelloWorldApp.java\" onclick=\"showCode(\'../../displayCode.html\', \'../application/examples/HelloWorldApp.java\'); return false;\"><code>HelloWorldApp.java</code></a>` on your computer and avoid a lot of typing. Then, you can go straight to [Compile the Source File](https://docs.oracle.com/javase/tutorial/getStarted/cupojava/unix.html#unix-2b).\r\n* Or, you can use the following (longer) instructions.\r\n\r\nFirst, open a shell, or \"terminal,\" window.\r\n\r\n![A new terminal window.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/ebea21f4-8a24-4662-887a-4027738eb9e6.gif)\r\n\r\nA new terminal window.\r\n\r\nWhen you first bring up the prompt, your *current directory* will usually be your *home directory*. You can change your current directory to your home directory at any time by typing `cd` at the prompt and then pressing **Return**.\r\n\r\nThe source files you create should be kept in a separate directory. You can create a directory by using the command `mkdir`. For example, to create the directory `examples/java` in the /tmp directory, use the following commands:\r\n\r\n```\r\ncd /tmp\r\nmkdir examples\r\ncd examples\r\nmkdir java\r\n```\r\n\r\nTo change your current directory to this new directory, you then enter:\r\n\r\n```\r\ncd /tmp/examples/java\r\n```\r\n\r\nNow you can start creating your source file.\r\n\r\nStart the Pico editor by typing `pico` at the prompt and pressing **Return**. If the system responds with the message `pico: command not found`, then Pico is most likely unavailable. Consult your system administrator for more information, or use another editor.\r\n\r\nWhen you start Pico, it\'ll display a new, blank *buffer*. This is the area in which you will type your code.\r\n\r\nType the following code into the new buffer:\r\n\r\n```\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply prints \"Hello World!\" to standard output.\r\n */\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); // Display the string.\r\n    }\r\n}\r\n```\r\n\r\n**Be Careful When You Type** ![uppercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/ea1d7dcb-1161-4687-8ee0-c144e9791965.gif)   ![lowercase letter A](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/db0e95ed-2f7a-4954-9a10-b4940de17a73.gif)\r\n\r\n---\r\n\r\n**Note:** Type all code, commands, and file names exactly as shown. Both the compiler (`javac`) and launcher (`java`) are *case-sensitive*, so you must capitalize consistently.\r\n\r\n`HelloWorldApp` is *not* the same as `helloworldapp`.---\r\n\r\nSave the code in a file with the name `HelloWorldApp.java`. In the Pico editor, you do this by typing **Ctrl-O** and then, at the bottom where you see the prompt `File Name to write:`, entering the directory in which you wish to create the file, followed by `HelloWorldApp.java`. For example, if you wish to save `HelloWorldApp.java` in the directory `/tmp/examples/java`, then you type `/tmp/examples/java/HelloWorldApp.java` and press **Return**.\r\n\r\nYou can type **Ctrl-X** to exit Pico.',NULL,0,0,17,2,now(),NULL,NULL),
	(11,'### Compile the Source File into a `.class` File\r\n\r\nBring up another shell window. To compile your source file, change your current directory to the directory where your file is located. For example, if your source directory is `/tmp/examples/java`, type the following command at the prompt and press **Return**:\r\n\r\n```\r\ncd /tmp/examples/java\r\n```\r\n\r\nIf you enter `pwd` at the prompt, you should see the current directory, which in this example has been changed to `/tmp/examples/java`.\r\n\r\nIf you enter `ls` at the prompt, you should see your file.\r\n\r\n![Results of the ls command, showing the .java source file.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/be4992ef-b843-45a1-8e34-01b1c3d7f393.gif)\r\n\r\nResults of the `ls` command, showing the `.java` source file.\r\n\r\nNow are ready to compile the source file. At the prompt, type the following command and press **Return**.\r\n\r\n```\r\njavac HelloWorldApp.java\r\n```\r\n\r\nThe compiler has generated a bytecode file, `HelloWorldApp.class`. At the prompt, type `ls` to see the new file that was generated: the following figure.\r\n\r\n![Results of the ls command, showing the generated .class file.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/95673bb8-6006-461c-a3c2-b3493b8b9743.gif)\r\n\r\nResults of the `ls` command, showing the generated `.class` file.\r\n\r\nNow that you have a `.class` file, you can run your program.\r\n\r\nIf you encounter problems with the instructions in this step, consult the [Common Problems (and Their Solutions)](https://docs.oracle.com/javase/tutorial/getStarted/problems/index.html).\r\n\r\n### Run the Program\r\n\r\nIn the same directory, enter at the prompt:\r\n\r\n```\r\njava HelloWorldApp\r\n```\r\n\r\nThe next figure shows what you should now see.\r\n\r\n![The output prints Hello World! to the screen.](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/8c55906b-0048-4d65-a05c-b93b730cb9fa.gif)\r\n\r\nThe output prints \"Hello World!\" to the screen.\r\n\r\nCongratulations! Your program works!\r\n\r\nIf you encounter problems with the instructions in this step, consult the [Common Problems (and Their Solutions)](https://docs.oracle.com/javase/tutorial/getStarted/problems/index.html).',NULL,0,0,17,2,now(),NULL,NULL),
	(12,'Now that you\'ve seen the \"Hello World!\" application (and perhaps even compiled and run it), you might be wondering how it works. Here again is its code:\r\n\r\n```\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); // Display the string.\r\n    }\r\n}\r\n```\r\n\r\nThe \"Hello World!\" application consists of three primary components: [source code comments](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html#COMMENTS), [the `HelloWorldApp` class definition](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html#CLASS_DEF), and [the `main` method](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html#MAIN). The following explanation will provide you with a basic understanding of the code, but the deeper implications will only become apparent after you\'ve finished reading the rest of the tutorial.\r\n\r\n## [Source Code Comments]()\r\n\r\n[The following bold text defines the *comments* of the &#34;Hello World!&#34; application:]()\r\n\r\n<pre><b>/**\r\n * The HelloWorldApp class implements an application that\r\n * simply prints &#34;Hello World!&#34; to standard output.\r\n */</b>\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(&#34;Hello World!&#34;); <b>// Display the string.</b>\r\n    }\r\n}\r\n</pre>\r\n\r\nComments are ignored by the compiler but are useful to other programmers. The Java programming language supports three kinds of comments:\r\n\r\n`/*<span> </span><em>text</em><span> </span>*/` The compiler ignores everything from `/*` to `*/`.`/**<span> </span><em>documentation</em><span> </span>*/` This indicates a documentation comment (*doc comment*, for short). The compiler ignores this kind of comment, just like it ignores comments that use `/*` and `*/`. The `javadoc` tool uses doc comments when preparing automatically generated documentation. For more information on `javadoc`, see the [Javadoc™ tool documentation](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html) .`//<span> </span><em>text</em>` The compiler ignores everything from `//` to the end of the line.## [The `HelloWorldApp` Class Definition]()\r\n\r\n[The following bold text begins the class definition block for the &#34;Hello World!&#34; application:]()\r\n\r\n```\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply displays \"Hello World!\" to the standard output.\r\n */\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); // Display the string.\r\n    }\r\n}\r\n```\r\n\r\nAs shown above, the most basic form of a class definition is:\r\n\r\n```\r\nclass name {\r\n    . . .\r\n}\r\n```\r\n\r\nThe keyword `class` begins the class definition for a class named `name`, and the code for each class appears between the opening and closing curly braces marked in bold above. Chapter 2 provides an overview of classes in general, and Chapter 4 discusses classes in detail. For now it is enough to know that every application begins with a class definition.',NULL,0,0,18,2,now(),NULL,NULL),
	(13,'## [The `main` Method]()\r\n\r\n[The following bold text begins the definition of the `main` method:]()\r\n\r\n```\r\n/**\r\n * The HelloWorldApp class implements an application that\r\n * simply displays \"Hello World!\" to the standard output.\r\n */\r\nclass HelloWorldApp {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\"); //Display the string.\r\n    }\r\n}\r\n```\r\n\r\nIn the Java programming language, every application must contain a `main` method whose signature is:\r\n\r\n```\r\npublic static void main(String[] args)\r\n```\r\n\r\nThe modifiers `public` and `static` can be written in either order (`public static` or `static public`), but the convention is to use `public static` as shown above. You can name the argument anything you want, but most programmers choose \"args\" or \"argv\".\r\n\r\nThe `main` method is similar to the `main` function in C and C++; it\'s the entry point for your application and will subsequently invoke all the other methods required by your program.\r\n\r\nThe `main` method accepts a single argument: an array of elements of type `String`.\r\n\r\n```\r\npublic static void main(String[] args)\r\n```\r\n\r\nThis array is the mechanism through which the runtime system passes information to your application. For example:\r\n\r\n```\r\njava MyApp arg1 arg2\r\n```\r\n\r\nEach string in the array is called a *command-line argument*. Command-line arguments let users affect the operation of the application without recompiling it. For example, a sorting program might allow the user to specify that the data be sorted in descending order with this command-line argument:\r\n\r\n```\r\n-descending\r\n```\r\n\r\nThe \"Hello World!\" application ignores its command-line arguments, but you should be aware of the fact that such arguments do exist.\r\n\r\nFinally, the line:\r\n\r\n```\r\nSystem.out.println(\"Hello World!\");\r\n```\r\n\r\nuses the `System` class from the core library to print the \"Hello World!\" message to standard output. Portions of this library (also known as the \"Application Programming Interface\", or \"API\") will be discussed throughout the remainder of the tutorial.',NULL,0,0,18,2,now(),NULL,NULL),
	(14,'## [Compiler Problems]()\r\n\r\n**Common Error Messages on Microsoft Windows Systems**\r\n\r\n`<strong>\'javac\' is not recognized as an internal or external command, operable program or batch file</strong>`\r\n\r\nIf you receive this error, Windows cannot find the compiler (`javac`).\r\n\r\nHere\'s one way to tell Windows where to find `javac`. Suppose you installed the JDK in `C:\\jdk1.8.0`. At the prompt you would type the following command and press Enter:\r\n\r\n```\r\nC:\\jdk1.8.0\\bin\\javac HelloWorldApp.java\r\n```\r\n\r\nIf you choose this option, you\'ll have to precede your `javac` and `java` commands with `C:\\jdk1.8.0\\bin\\` each time you compile or run a program. To avoid this extra typing, consult the section [Updating the PATH variable](https://docs.oracle.com/javase/8/docs/technotes/guides/install/windows_jdk_install.html#BABGDJFH) in the JDK 8 installation instructions.\r\n\r\n`<strong>Class names, \'HelloWorldApp\', are only accepted if annotation processing is explicitly requested</strong>`\r\n\r\nIf you receive this error, you forgot to include the `.java` suffix when compiling the program. Remember, the command is `javac HelloWorldApp.java` not `javac HelloWorldApp`.\r\n\r\n**Common Error Messages on UNIX Systems**\r\n\r\n`javac: Command not found`\r\n\r\nIf you receive this error, UNIX cannot find the compiler, `javac`.\r\n\r\nHere\'s one way to tell UNIX where to find `javac`. Suppose you installed the JDK in `/usr/local/jdk1.8.0`. At the prompt you would type the following command and press Return:\r\n\r\n```\r\n/usr/local/jdk1.8.0/javac HelloWorldApp.java\r\n```\r\n\r\n**Note:** If you choose this option, each time you compile or run a program, you\'ll have to precede your `javac` and `java` commands with `/usr/local/jdk1.8.0/`. To avoid this extra typing, you could add this information to your PATH variable. The steps for doing so will vary depending on which shell you are currently running.\r\n\r\n`<strong>Class names, \'HelloWorldApp\', are only accepted if annotation processing is explicitly requested</strong>`\r\n\r\nIf you receive this error, you forgot to include the `.java` suffix when compiling the program. Remember, the command is `javac HelloWorldApp.java` not `javac HelloWorldApp`.\r\n\r\n**Syntax Errors (All Platforms)**\r\n\r\nIf you mistype part of a program, the compiler may issue a *syntax* error. The message usually displays the type of the error, the line number where the error was detected, the code on that line, and the position of the error within the code. Here\'s an error caused by omitting a semicolon (`;`) at the end of a statement:\r\n\r\n```\r\nTesting.java:8: error: \';\' expected\r\n            count++\r\n                   ^\r\n1 error\r\n```\r\n\r\nIf you see any compiler errors, then your program did not successfully compile, and the compiler did not create a `.class` file. Carefully verify the program, fix any errors that you detect, and try again.\r\n\r\n**Semantic Errors**\r\n\r\nIn addition to verifying that your program is syntactically correct, the compiler checks for other basic correctness. For example, the compiler warns you each time you use a variable that has not been initialized:\r\n\r\n```\r\nTesting.java:8: error: variable count might not have been initialized\r\n            count++;\r\n            ^\r\nTesting.java:9: error: variable count might not have been initialized\r\n        System.out.println(\"Input has \" + count + \" chars.\");\r\n                                          ^\r\n2 errors\r\n```\r\n\r\nAgain, your program did not successfully compile, and the compiler did not create a `.class` file. Fix the error and try again.',NULL,0,0,19,2,now(),NULL,NULL),
	(15,'## [Runtime Problems]()\r\n\r\nError Messages on Microsoft Windows Systems\r\n\r\n`Exception in thread \"main\" java.lang.NoClassDefFoundError: HelloWorldApp`\r\n\r\nIf you receive this error, `java` cannot find your bytecode file, `HelloWorldApp.class`.\r\n\r\nOne of the places `java` tries to find your `.class` file is your current directory. So if your `.class` file is in `C:\\java`, you should change your current directory to that. To change your directory, type the following command at the prompt and press Enter:\r\n\r\n```\r\ncd c:\\java\r\n```\r\n\r\nThe prompt should change to `C:\\java>`. If you enter `dir` at the prompt, you should see your `.java` and `.class` files. Now enter `java HelloWorldApp` again.\r\n\r\nIf you still have problems, you might have to change your CLASSPATH variable. To see if this is necessary, try clobbering the classpath with the following command.\r\n\r\n```\r\nset CLASSPATH=\r\n```\r\n\r\nNow enter `java HelloWorldApp` again. If the program works now, you\'ll have to change your CLASSPATH variable. To set this variable, consult the [Updating the PATH variable](https://docs.oracle.com/javase/8/docs/technotes/guides/install/windows_jdk_install.html#BABGDJFH) section in the JDK 8 installation instructions. The CLASSPATH variable is set in the same manner.\r\n\r\n`<strong>Could not find or load main class HelloWorldApp.class</strong>`\r\n\r\nA common mistake made by beginner programmers is to try and run the `java` launcher on the `.class` file that was created by the compiler. For example, you\'ll get this error if you try to run your program with `java HelloWorldApp.class` instead of `java HelloWorldApp`. Remember, the argument is the *name of the class* that you want to use, *not* the filename.\r\n\r\n**`Exception in thread \"main\" java.lang.NoSuchMethodError: main`**\r\n\r\nThe Java VM requires that the class you execute with it have a `main` method at which to begin execution of your application. [A Closer Look at the &#34;Hello World!&#34; Application](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html) discusses the `main` method in detail.\r\n\r\n**Error Messages on UNIX Systems**\r\n\r\n`Exception in thread \"main\" java.lang.NoClassDefFoundError: HelloWorldApp`\r\n\r\nIf you receive this error, `java` cannot find your bytecode file, `HelloWorldApp.class`.\r\n\r\nOne of the places `java` tries to find your bytecode file is your current directory. So, for example, if your bytecode file is in `/home/jdoe/java`, you should change your current directory to that. To change your directory, type the following command at the prompt and press Return:\r\n\r\n```\r\ncd /home/jdoe/java\r\n```\r\n\r\nIf you enter `pwd` at the prompt, you should see `/home/jdoe/java`. If you enter `ls` at the prompt, you should see your `.java` and `.class` files. Now enter `java HelloWorldApp` again.\r\n\r\nIf you still have problems, you might have to change your CLASSPATH environment variable. To see if this is necessary, try clobbering the classpath with the following command.\r\n\r\n```\r\nunset CLASSPATH\r\n```\r\n\r\nNow enter `java HelloWorldApp` again. If the program works now, you\'ll have to change your CLASSPATH variable in the same manner as the PATH variable above.\r\n\r\n`<strong>Exception in thread \"main\" java.lang.NoClassDefFoundError: HelloWorldApp/class</strong>`\r\n\r\nA common mistake made by beginner programmers is to try and run the `java` launcher on the `.class` file that was created by the compiler. For example, you\'ll get this error if you try to run your program with `java HelloWorldApp.class` instead of `java HelloWorldApp`. Remember, the argument is the *name of the class* that you want to use, *not* the filename.\r\n\r\n**`Exception in thread \"main\" java.lang.NoSuchMethodError: main`**\r\n\r\nThe Java VM requires that the class you execute with it have a `main` method at which to begin execution of your application. [A Closer Look at the &#34;Hello World!&#34; Application](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html) discusses the `main` method in detail.\r\n\r\n**Applet or Java Web Start Application Is Blocked**\r\n\r\nIf you are running an application through a browser and get security warnings that say the application is blocked, check the following items:\r\n\r\n* Verify that the attributes in the JAR file manifest are set correctly for the environment in which the application is running. The Permissions attribute is required. In a NetBeans project, you can open the manifest file from the Files tab of the NetBeans IDE by expanding the project folder and double-clicking manifest.mf.\r\n* Verify that the application is signed by a valid certificate and that the certificate is located in the Signer CA keystore.\r\n* If you are running a local applet, set up a Web server to use for testing. You can also add your application to the exception site list, which is managed in the Security tab of the Java Control Panel.',NULL,0,0,19,2,now(),NULL,NULL),
	(16,'You have reached the end of the \"Getting Started\" trail.\r\n\r\nIf you have comments or suggestions about this trail, use our [feedback page](https://docs.oracle.com/javase/feedback.html) to tell us about it.\r\n\r\n![Java trail](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/b28ac8d3-b60f-4e0e-9f51-256c4ba1b0ad.gif)[Learning the Java Language](https://docs.oracle.com/javase/tutorial/java/index.html): This trail is a gentle introduction to object-oriented concepts and how the Java language implements them.\r\n\r\n![Core trail](https://iae-img.oss-cn-shenzhen.aliyuncs.com/iae-proofread/upload/vd/555f04d9-2424-4cc8-8a2a-d579638c86e9.gif)[Essential Java Classes](https://docs.oracle.com/javase/tutorial/essential/index.html): By taking this trail, you can find out about strings, exceptions, threads, and other Java features that are used in all kinds of Java programs.\r\n\r\n',NULL,0,0,20,2,now(),NULL,NULL);


